<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dialog Editor</title>
    
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=JetBrains+Mono:wght@400&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #252526;
            --bg-header: #333333;
            --bg-node: #2d2d30;
            --bg-group: rgba(255, 255, 255, 0.05);
            --accent: #569cd6;
            --error: #f48771;
            --success: #89d185;
            --text-main: #cccccc;
            --text-muted: #858585;
            --border: #3e3e42;
            --grid-line: #2a2a2a;
            --drag-target: rgba(86, 156, 214, 0.2);
            --drag-remove: rgba(209, 105, 105, 0.2);
            --border-remove: #d16969;
        }

        [v-cloak] { display: none; }
        * { box-sizing: border-box; user-select: none; outline: none; }
        body { margin: 0; padding: 0; font-family: 'Inter', sans-serif; background: var(--bg-dark); color: var(--text-main); overflow: hidden; height: 100vh; display: flex; }
        
        /* Utility */
        .flex { display: flex; }
        .col { flex-direction: column; }
        .row { flex-direction: row; }
        .grow { flex-grow: 1; }
        .center { align-items: center; justify-content: center; }
        .wrap { flex-wrap: wrap; }
        .justify-end { justify-content: flex-end; }
        .gap-sm { gap: 8px; }
        .p-sm { padding: 8px; }
        .text-sm { font-size: 12px; }
		.text-group-header { font-size: 20px; background:none; border:none; color: #7a7a7a; width:100% }
        .text-muted { color: var(--text-muted); }
        .bold { font-weight: 600; }
        .icon { font-family: 'Material Symbols Outlined'; font-size: 18px; line-height: 1; user-select: none; }
        .ml-2 { margin-left: 8px; }
        .mr-2 { margin-right: 8px; }
        .mt-1 { margin-top: 4px; }
        .mt-2 { margin-top: 8px; }
        .mt-3 { margin-top: 16px; }
        .mb-1 { margin-bottom: 4px; }
		.mb-2 { margin-bottom: 8px; }
		.mb-3 { margin-bottom: 16px; }
        
        button {
            background: var(--bg-header); border: 1px solid var(--border); color: var(--text-main);
            padding: 4px 12px; border-radius: 4px; cursor: pointer; transition: 0.2s;
            display: inline-flex; align-items: center; justify-content: center;
        }
        button:hover { background: var(--border); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        button.primary { background: var(--accent); color: white; border: none; }
        button.full-width { width: 100%; text-align: center; margin-bottom: 5px; padding: 8px; }
        button.small { padding: 2px 6px; font-size: 10px; height: 20px; }
        button.icon-btn { padding: 4px; }
        button.icon-btn .icon { font-size: 16px; }
        
        input, select, textarea {
            background: #111; border: 1px solid var(--border); color: var(--text-main);
            padding: 4px; border-radius: 2px; font-family: 'Inter', sans-serif; width: 100%;
        }
        input:focus, select:focus, textarea:focus { border-color: var(--accent); }
        input.error, select.error, textarea.error { border-color: var(--error); }

        .toggle-checkbox { appearance: none; display: none; }
        .toggle-label {
            position: relative; width: 36px; height: 18px;
            background: #444; border: 1px solid var(--border);
            border-radius: 9px; cursor: pointer; transition: 0.2s;
            flex-shrink: 0;
        }
        .toggle-checkbox:checked + .toggle-label { background: var(--accent); border-color: var(--accent); }
        .toggle-label::after { content: ''; position: absolute; top: 1px; left: 1px; width: 14px; height: 14px; background: white; border-radius: 50%; transition: 0.2s; }
        .toggle-checkbox:checked + .toggle-label::after { left: 19px; }

        #app { display: flex; width: 100%; height: 100%; }
        
        .sidebar { width: 300px; background: var(--bg-panel); border-right: 1px solid var(--border); display: flex; flex-direction: column; z-index: 10; flex-shrink: 0; height: 100vh; overflow: hidden; }
        .sidebar-header { padding: 10px; background: var(--bg-header); font-weight: 600; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
        .sidebar-content { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; min-height: 0; }
        
        .section { border-bottom: 1px solid var(--border); display: flex; flex-direction: column; flex-shrink: 0; }
        .section-header { padding: 8px 12px; cursor: pointer; background: var(--bg-panel); display: flex; align-items: center; font-size: 13px; font-weight: 600; flex-shrink: 0; }
        .section-header:hover { background: #2a2d2e; }
        .section.grow { flex-grow: 1; min-height: 0; display: flex; flex-direction: column; overflow: hidden; } 
        .section-body { padding: 8px; background: #1e1e1e; }
        .section.grow .section-body { flex-grow: 1; overflow-y: auto; }

        .list-item { padding: 6px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 8px; margin-bottom: 2px; }
        .list-item:hover { background: #2a2d2e; }
        .list-item.active { background: var(--accent); color: white; }
        
        .tree-item { padding-left: 10px; border-left: 1px solid #333; margin-left: 4px; }
        .tree-row { display: flex; align-items: center; gap: 6px; padding: 4px; border-radius: 4px; cursor: pointer; }
        .tree-row:hover { background: #2a2d2e; }
        .tree-row.active { background: var(--accent); color: white; }
        .tree-row.drag-over { background: var(--drag-target); outline: 1px dashed var(--accent); }

        .drag-handle { cursor: grab; color: #666; font-size: 16px; }
        .drag-handle:active { cursor: grabbing; }
        
        .canvas-container { flex-grow: 1; position: relative; overflow: hidden; background: #111; cursor: default; }
        .grid-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background-image: linear-gradient(var(--grid-line) 1px, transparent 1px), linear-gradient(90deg, var(--grid-line) 1px, transparent 1px); opacity: 0.5; }
        .graph-layer { position: absolute; top: 0; left: 0; transform-origin: 0 0; width: 0; height: 0; }
        
        .overlay-no-dialog {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(30, 30, 30, 0.9); z-index: 50; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        .overlay-toolbar { position: absolute; bottom: 20px; left: 20px; background: var(--bg-panel); border: 1px solid var(--border); border-radius: 4px; display: flex; gap: 5px; padding: 5px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); z-index: 20; }
        .dialog-vars-overlay { position: absolute; top: 10px; left: 10px; width: 280px; background: var(--bg-panel); border: 1px solid var(--border); border-radius: 4px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 5; display: flex; flex-direction: column; }
        .dialog-vars-header { padding: 8px 12px; background: var(--bg-header); font-weight: 600; font-size: 13px; cursor: pointer; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid var(--border); }
        .dialog-vars-body { padding: 10px; overflow-y: auto; max-height: 400px; background: var(--bg-dark); }
        .selection-rect { position: fixed; background: rgba(86, 156, 214, 0.15); border: 1px solid var(--accent); z-index: 1000; pointer-events: none; }

        .node { position: absolute; min-width: 200px; width: auto; background: var(--bg-node); border: 1px solid var(--border); border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); display: flex; flex-direction: column; z-index: 2; transition: left 0.05s, top 0.05s; }
        .node.selected { border: 1px solid var(--accent); box-shadow: 0 0 0 2px rgba(86, 156, 214, 0.3); }
        .node-header { padding: 8px 12px; background: var(--bg-header); border-radius: 8px 8px 0 0; font-weight: 600; font-size: 13px; display: flex; align-items: center; gap: 6px; cursor: grab; position: relative; }
        .node-header:active { cursor: grabbing; }
        .node-body { padding: 12px; display: flex; flex-direction: column; gap: 10px; cursor: default; }
        
        .node.group { background: var(--bg-group); border: 2px dashed #555; z-index: 0; box-shadow: none; transition: none; }
        .node.group.selected { border-color: var(--accent); }
        .node.group.drag-target { background: var(--drag-target); border-color: var(--accent); }
        .node.group.remove-target { background: var(--drag-remove); border-color: var(--border-remove); }
        .node.group .node-header { background: transparent; border-bottom: none; cursor: grab; }

        .socket-row { display: flex; justify-content: space-between; align-items: center; min-height: 24px; position: relative; }
        .socket-row.right { justify-content: flex-end; }
        .socket-row.left { justify-content: flex-start; }
        .socket-row.center { justify-content: center; }
        
        .socket-hitbox { width: 24px; height: 24px; margin: -6px; display: flex; align-items: center; justify-content: center; cursor: crosshair; }
        .socket { width: 12px; height: 12px; background: #888; border: 2px solid var(--bg-node); transition: 0.2s; pointer-events: none; }
        .socket-hitbox:hover .socket { transform: scale(1.3); border-color: white; }
        .socket-hitbox.can-drop .socket { box-shadow: 0 0 5px 2px var(--accent); background: white !important; }

        svg.connections { position: absolute; top: 0; left: 0; width: 1px; height: 1px; overflow: visible; z-index: 1; pointer-events: none; }
        .connector { cursor: pointer; }
        .connector path.cable-hit { fill: none; stroke: transparent; stroke-width: 20px; pointer-events: stroke; }
        .connector path.cable-vis { fill: none; stroke: #888; stroke-width: 2px; pointer-events: none; transition: stroke 0.1s, stroke-width 0.1s; }
        .connector:hover path.cable-vis { stroke: var(--accent); stroke-width: 4px; }
        .connector.selected path.cable-vis { stroke: var(--accent); stroke-width: 3px; }
        path.drag-line { stroke: var(--accent); stroke-dasharray: 5,5; opacity: 0.8; pointer-events: none; fill: none; stroke-width: 2px; }

        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 100; display: flex; align-items: center; justify-content: center; }
        .modal { background: var(--bg-panel); padding: 20px; border-radius: 8px; border: 1px solid var(--border); width: 450px; max-width: 90%; display: flex; flex-direction: column; gap: 10px; max-height: 90vh; overflow-y: auto;}
        .tag { font-size: 10px; padding: 2px 6px; border-radius: 4px; background: #333; margin: 0; cursor:pointer; display: inline-flex; align-items: center; justify-content: center;}
        .tag.active { background: var(--accent); color: white; }
        
        .context-menu { position: fixed; width: 220px; background: var(--bg-panel); border: 1px solid var(--border); box-shadow: 0 8px 24px rgba(0,0,0,0.6); z-index: 50; padding: 4px; border-radius: 6px; display: flex; flex-direction: column; }
        .ctx-search { background: #111; border: 1px solid #333; padding: 6px; color: var(--text-main); width: 100%; font-size: 12px; border-radius: 4px; margin-bottom: 4px; }
        .ctx-group-label { font-size: 10px; font-weight: 600; color: #666; text-transform: uppercase; padding: 4px 8px; margin-top: 4px; letter-spacing: 0.5px; }
        .context-item { padding: 6px 12px; cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 8px; border-radius: 4px; transition: background 0.1s; }
        .context-item:hover, .context-item.active { background: var(--accent); color: white; }
        .context-item .icon { font-size: 16px; opacity: 0.8; }

        .warning-icon { color: var(--error); cursor: help; margin-right: 4px; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }

        .toast-container { position: fixed; top: 20px; right: 20px; z-index: 9999; display: flex; flex-direction: column; align-items: flex-end; gap: 10px; pointer-events: none; }
        .toast-item { pointer-events: auto; background: var(--bg-panel); border: 1px solid var(--border); border-left-width: 4px; padding: 12px 16px; border-radius: 4px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); width: 320px; color: var(--text-main); cursor: pointer; position: relative; overflow: hidden; }
        .toast-item:hover { background: #2a2d2e; }
        .toast-success { border-left-color: var(--success); }
        .toast-error { border-left-color: var(--error); }
        .toast-warning { border-left-color: #cca700; }
        .toast-info { border-left-color: var(--accent); }
        .toast-icon { font-size: 20px; margin-top: -1px; }
        .toast-success .toast-icon { color: var(--success); }
        .toast-error .toast-icon { color: var(--error); }
        .toast-warning .toast-icon { color: #cca700; }
        .toast-info .toast-icon { color: var(--accent); }
        .toast-message { display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; white-space: pre-wrap; font-size: 13px; line-height: 1.4; word-break: break-word; }
        .toast-message.expanded { -webkit-line-clamp: unset; }
        .toast-expand-btn { background: none; border: none; color: var(--accent); font-size: 11px; padding: 0; margin-top: 6px; cursor: pointer; text-align: left; display: inline-block; }
        .toast-expand-btn:hover { text-decoration: underline; background: none; }
        .toast-anim-move, .toast-anim-enter-active, .toast-anim-leave-active { transition: all 0.3s ease; }
        .toast-anim-enter-from, .toast-anim-leave-to { opacity: 0; transform: translateX(100%); }
        .toast-anim-leave-active { position: absolute; }
    </style>
</head>
<body>

<div id="app" v-cloak @mousedown="ui.contextMenu.visible = false">

    <div class="toast-container" @mouseenter="toastSystem.isPaused = true" @mouseleave="toastSystem.isPaused = false">
        <transition-group name="toast-anim">
            <div v-for="toast in toastSystem.toasts" :key="toast.id" class="toast-item" :class="'toast-' + toast.type" @click="removeToast(toast.id)">
                <div class="flex gap-sm" style="align-items: flex-start">
                    <span class="icon toast-icon" v-html="getToastIcon(toast.type)"></span>
                    <div class="flex col grow">
                        <div class="toast-message" :class="{expanded: toast.expanded}">{{ toast.message }}</div>
                        <button v-if="needsExpand(toast.message)" class="toast-expand-btn" @click.stop="toast.expanded = !toast.expanded">
                            {{ toast.expanded ? 'Show less' : 'Show more' }}
                        </button>
                    </div>
                </div>
            </div>
        </transition-group>
    </div>
    
    <div v-if="modal.visible" class="overlay" style="z-index: 200;" @mousedown.stop>
        <div class="modal" style="width: 320px;">
            <h3 style="margin-top:0">{{ modal.title }}</h3>
            <p v-if="modal.message" style="margin: 10px 0; font-size:13px; color:#ccc;">{{ modal.message }}</p>
            <input v-if="modal.type === 'prompt'" v-model="modal.inputValue" ref="modalInput" class="mb-1" style="width:100%; margin-bottom:15px;" @keyup.enter="confirmModal">
            <div class="flex gap-sm justify-end">
                <button @click="closeModal">Cancel</button>
                <button class="primary" @click="confirmModal">OK</button>
            </div>
        </div>
    </div>

    <div class="sidebar" @mousedown.stop>
        <div class="sidebar-header">
            <span>Dialog Editor</span>
            <button class="icon-btn" title="Export/Import" @click="showExport = true"><span class="icon">save</span></button>
        </div>

        <div class="sidebar-content">
            <div class="section">
                <div class="section-header" @click="toggle('settings')">
                    <span class="icon">{{ ui.sections.settings ? 'expand_more' : 'chevron_right' }}</span>
                    Settings
                </div>
                <div class="section-body" v-if="ui.sections.settings">
                    <label class="text-sm">Language</label>
                    <div class="flex wrap gap-sm mt-2">
                        <button class="tag" v-for="lang in project.settings.languages" :key="lang" :class="{ active: project.settings.currentLang === lang }" @click="project.settings.currentLang = lang">{{ lang.toUpperCase() }}</button>
                    </div>
                    <div class="flex gap-sm mt-2">
                        <input v-model="newLang" placeholder="Add Language" class="text-sm">
                        <button class="icon-btn" title="Add Language" @click="addLang"><span class="icon">add</span></button>
                    </div>
                    <div class="flex center mt-3 mb-3" style="border-top:1px solid #333;"></div>
                    <div class="flex center gap-sm mb-2">
                         <label class="text-sm">Grid Size</label>
                         <input type="number" v-model="editor.gridSize" class="text-sm" style="width:50px">
                         <label class="text-sm ml-2">Snap</label>
                         <input type="checkbox" v-model="editor.snap">
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-header" @click="toggle('vars')">
                    <span class="icon">{{ ui.sections.vars ? 'expand_more' : 'chevron_right' }}</span>
                    Variables
                    <div class="flex gap-sm ml-2" style="margin-left:auto">
						<button class="tag icon-btn" title="Add Variable" @click.stop="addVariable"><span class="icon">add</span></button>
					</div>
                </div>
                <div class="section-body" v-if="ui.sections.vars">
                    <div v-if="project.variables.length === 0" class="text-sm text-muted" style="text-align:center; padding: 10px;">No variables created.</div>
                    <div v-for="v in project.variables" :key="v.id" class="list-item" style="display:block; cursor:default;" @input="validateVars">
                        <div class="flex gap-sm center">
                            <span class="icon drag-handle" draggable="true" @dragstart.stop="setDrag(v.id, 'variable')">drag_indicator</span>
                            <span v-if="validationErrors[v.id]" class="icon warning-icon" style="font-size:14px" :title="validationErrors[v.id].join('\n')">warning</span>
                            <input v-model="v.name" @focus="saveSnapshot(v, 'name')" @change="e => commitProp(v, 'name', e.target.value)" class="text-sm grow" :class="{error: validationErrors[v.id]}" @input="validateVars">
                            <button class="icon-btn" title="Delete Variable" @click="deleteVariable(v.id)"><span class="icon">delete</span></button>
                        </div>
                        <div class="flex gap-sm mt-2 center">
                            <select v-model="v.type" class="text-sm" style="width: 70px;">
                                <option value="bool">Bool</option>
                                <option value="int">Int</option>
                                <option value="float">Float</option>
                                <option value="string">Str</option>
                            </select>
                            
                            <template v-if="v.type === 'bool'">
                                <div class="grow flex center">
                                    <input type="checkbox" :id="'gvar-'+v.id" class="toggle-checkbox" v-model="v.value" true-value="true" false-value="false">
                                    <label :for="'gvar-'+v.id" class="toggle-label"></label>
                                    <span class="text-sm ml-2">{{ v.value === 'true' ? 'True' : 'False' }}</span>
                                </div>
                            </template>
                            <template v-else>
                                <input v-model="v.value" @focus="saveSnapshot(v, 'value')" @change="e => commitProp(v, 'value', e.target.value)" class="text-sm grow" placeholder="Default">
                            </template>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-header" @click="toggle('chars')">
                    <span class="icon">{{ ui.sections.chars ? 'expand_more' : 'chevron_right' }}</span>
                    Characters
                    <div class="flex gap-sm ml-2" style="margin-left:auto">
						<button class="tag icon-btn" title="Add Character" @click.stop="addCharacter"><span class="icon">person_add</span></button>
					</div>
                </div>
                <div class="section-body" v-if="ui.sections.chars">
                    <div v-if="project.characters.length === 0" class="text-sm text-muted" style="text-align:center; padding: 10px;">No characters created.</div>
                    <div v-for="c in project.characters" :key="c.id" class="list-item col" style="display: flex; align-items: stretch; cursor: default; margin-bottom: 8px;">
                        
                        <div class="flex gap-sm center" @click="toggleChar(c.id)" style="cursor: pointer; padding: 4px; border-radius: 4px; background: rgba(255,255,255,0.02);">
                            <span class="icon" style="font-size:16px; color:#888; width:16px">{{ collapsedCharacterIds.has(c.id) ? 'chevron_right' : 'expand_more' }}</span>
                            <span v-if="validationErrors[c.id]" class="icon warning-icon" style="font-size:14px" :title="validationErrors[c.id].join('\n')">warning</span>
                            <input type="color" v-model="c.color" style="width:24px; height:24px; padding:0; border:none; background:none; cursor: pointer;" @click.stop>
                            <input v-model="c.name" @focus="saveSnapshot(c, 'name')" @change="e => commitProp(c, 'name', e.target.value)" class="text-sm grow" :class="{error: validationErrors[c.id]}" @click.stop style="font-weight:600" @input="validateChars">
                            <button class="icon-btn" @click.stop="addCharacterVariable(c.id)" title="Add Character Variable"><span class="icon">playlist_add</span></button>
                            <button class="icon-btn" @click.stop="deleteCharacter(c.id)" title="Delete Character"><span class="icon">delete</span></button>
                        </div>
                        
                        <div v-if="!collapsedCharacterIds.has(c.id)" style="padding-left: 24px;">
                            <div class="mt-2 mb-2">
                                <textarea v-model="c.description" @focus="saveSnapshot(c, 'description')" @change="e => commitProp(c, 'description', e.target.value)" class="text-sm" rows="2" placeholder="Description / Context (for translators & audio)" style="color:#aaa; font-size:11px; background: #222;"></textarea>
                            </div>

                            <div v-if="c.variables && c.variables.length > 0" class="mt-1" style="border-left: 1px solid #444; padding-left: 8px;">
                                <div v-for="cv in c.variables" :key="cv.id" class="flex col mb-1">
                                     <div class="flex gap-sm center">
                                        <span class="icon drag-handle" draggable="true" @dragstart.stop="setDrag(cv.id, 'variable')">drag_indicator</span>
                                        <span v-if="validationErrors[cv.id]" class="icon warning-icon" style="font-size:12px" :title="validationErrors[cv.id].join('\n')">warning</span>
                                        <input v-model="cv.name" @focus="saveSnapshot(cv, 'name')" @change="e => commitProp(cv, 'name', e.target.value)" class="text-sm grow" placeholder="Var Name" :class="{error: validationErrors[cv.id]}" style="background:#222" @input="validateChars">
                                        <button class="icon-btn" @click="deleteCharacterVariable(c.id, cv.id)" title="Delete Variable"><span class="icon">close</span></button>
                                     </div>
                                     <div class="flex gap-sm mt-1 center">
                                        <select v-model="cv.type" class="text-sm" style="width: 70px; background:#222">
                                            <option value="bool">Bool</option>
                                            <option value="int">Int</option>
                                            <option value="float">Float</option>
                                            <option value="string">Str</option>
                                        </select>
                                        
                                        <template v-if="cv.type === 'bool'">
                                            <div class="grow flex center">
                                                <input type="checkbox" :id="'cvar-'+c.id+'-'+cv.id" class="toggle-checkbox" v-model="cv.value" true-value="true" false-value="false">
                                                <label :for="'cvar-'+c.id+'-'+cv.id" class="toggle-label"></label>
                                                <span class="text-sm ml-2">{{ cv.value === 'true' ? 'True' : 'False' }}</span>
                                            </div>
                                        </template>
                                        <template v-else>
                                            <input v-model="cv.value" @focus="saveSnapshot(cv, 'value')" @change="e => commitProp(cv, 'value', e.target.value)" class="text-sm grow" placeholder="Def" style="background:#222">
                                        </template>
                                     </div>
                                </div>
                            </div>
                            <div v-else class="text-sm text-muted mt-1" style="font-style:italic; padding-left:8px">No variables</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section grow flex col">
                <div class="section-header" @click="toggle('dialogs')">
                    <span class="icon">{{ ui.sections.dialogs ? 'expand_more' : 'chevron_right' }}</span>
                    Dialogs
                    <div class="flex gap-sm ml-2" style="margin-left:auto">
                        <button class="tag icon-btn" title="New Folder" @click.stop="addFolder(null)"><span class="icon" style="font-size:16px">create_new_folder</span></button>
                        <button class="tag icon-btn" title="New Dialog" @click.stop="addDialog(null)"><span class="icon" style="font-size:16px">note_add</span></button>
                    </div>
                </div>
                <div class="section-body grow" style="padding:0; overflow:auto" @dragover.prevent @drop="onDrop(null)">
                    <tree-browser :parent-id="null"></tree-browser>
                </div>
            </div>
        </div>
    </div>

    <div class="canvas-container" 
         ref="canvasRef"
         @mousedown="onCanvasMouseDown"
         @mousemove="handleMove" 
         @mouseup="handleUp" 
         @wheel.prevent="handleZoom"
         @dragover.prevent
         @drop="onCanvasDrop">
        
        <div v-if="!activeDialog" class="overlay-no-dialog">
             <span class="icon" style="font-size: 64px; color: #444; margin-bottom: 16px;">forum</span>
             <h2 style="color: #666; margin: 0 0 8px 0;">No Dialog Selected</h2>
             <p class="text-muted text-sm">Select a dialog from the sidebar or create a new one.</p>
        </div>

        <div class="grid-layer" :style="{ backgroundPosition: `${pan.x}px ${pan.y}px`, backgroundSize: `${editor.gridSize * zoom}px ${editor.gridSize * zoom}px` }"></div>

        <div class="overlay-toolbar">
             <button class="icon-btn" title="Reset View" @click="fitView"><span class="icon">center_focus_strong</span></button>
			 <div style="width:1px; background:var(--border); margin:0 4px;"></div>
             <button class="icon-btn" title="Undo (Ctrl+Z)" @click="history.undo()" :disabled="history.past.length === 0"><span class="icon">undo</span></button>
             <button class="icon-btn" title="Redo (Ctrl+Y)" @click="history.redo()" :disabled="history.future.length === 0"><span class="icon">redo</span></button>
        </div>
        
        <div class="dialog-vars-overlay" @mousedown.stop @wheel.stop>
            <div class="dialog-vars-header" @click="ui.overlayCollapsed = !ui.overlayCollapsed">
                <span class="flex center gap-sm">
                    <span class="icon">{{ ui.overlayCollapsed ? 'expand_more' : 'expand_less' }}</span>
                    Dialog Variables
                </span>
                <button class="icon-btn" title="Add Dialog Variable" @click.stop="addDialogVariable"><span class="icon">add</span></button>
            </div>
            <div v-if="!ui.overlayCollapsed" class="dialog-vars-body">
                <div v-if="!activeDialog" class="text-sm text-muted">No dialog selected</div>
                <div v-else-if="!activeDialog.variables || activeDialog.variables.length === 0" class="text-sm text-muted" style="text-align:center; padding:5px">No local variables</div>
                
                <div v-if="activeDialog" v-for="v in activeDialog.variables" :key="v.id" class="list-item" style="display:block; cursor:default; background: #222; margin-bottom:5px; border:1px solid #333">
                    <div class="flex gap-sm center">
                        <span class="icon drag-handle" draggable="true" @dragstart.stop="setDrag(v.id, 'variable')">drag_indicator</span>
                        <span v-if="validationErrors[v.id]" class="icon warning-icon" style="font-size:12px" :title="validationErrors[v.id].join('\n')">warning</span>
                        <input v-model="v.name" @focus="saveSnapshot(v, 'name')" @change="e => commitProp(v, 'name', e.target.value)" class="text-sm grow" :class="{error: validationErrors[v.id]}" placeholder="Name" @input="markActiveDirty">
                        <button class="icon-btn" title="Delete" @click="deleteDialogVariable(v.id)"><span class="icon">close</span></button>
                    </div>
                    <div class="flex gap-sm mt-1 center">
                        <select v-model="v.type" class="text-sm" style="width: 70px;">
                            <option value="bool">Bool</option>
                            <option value="int">Int</option>
                            <option value="float">Float</option>
                            <option value="string">Str</option>
                        </select>
                        
                        <div class="flex center" title="Reset on Dialog Start?">
                            <input type="checkbox" :id="'dvr-'+v.id" v-model="v.resetOnStart" @change="markActiveDirty">
                            <label :for="'dvr-'+v.id" class="text-sm text-muted ml-1" style="font-size:10px; cursor:pointer">Reset</label>
                        </div>

                        <template v-if="v.type === 'bool'">
                            <div class="grow flex center">
                                <input type="checkbox" :id="'dvar-'+v.id" class="toggle-checkbox" v-model="v.value" true-value="true" false-value="false">
                                <label :for="'dvar-'+v.id" class="toggle-label"></label>
                                <span class="text-sm ml-2">{{ v.value === 'true' ? 'True' : 'False' }}</span>
                            </div>
                        </template>
                        <template v-else>
                            <input v-model="v.value" @focus="saveSnapshot(v, 'value')" @change="e => commitProp(v, 'value', e.target.value)" class="text-sm grow" placeholder="Def">
                        </template>
                    </div>
                </div>
            </div>
        </div>

        <div v-if="selectionRect.visible" class="selection-rect" 
             :style="{ left: selectionRect.x + 'px', top: selectionRect.y + 'px', width: selectionRect.w + 'px', height: selectionRect.h + 'px' }">
        </div>

        <div class="graph-layer" :style="{ transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})` }">
            <svg class="connections">
               <g v-for="conn in activeConnections" :key="conn.id" class="connector"
                  :class="{ selected: selectedConnectionId === conn.id }">
                    <path :d="getPath(conn)" class="cable-hit" @click.stop="selectConnection(conn.id)" />
                    <path :d="getPath(conn)" class="cable-vis" />
               </g>
               <path v-if="dragLinePath" :d="dragLinePath" class="cable drag-line" />
            </svg>

            <div v-for="node in activeNodes" :key="node.id"
                 class="node" :id="'node-' + node.id"
                 :class="{ 
                    selected: selectedNodeIds.has(node.id),
                    group: node.type === 'Group',
                    'drag-target': hoverGroupId === node.id,
                    'remove-target': removeGroupId === node.id
                 }"
                 :style="{ 
                    left: node.x + 'px', 
                    top: node.y + 'px', 
                    width: node.type === 'Group' ? node.data.w + 'px' : 'auto',
                    height: node.type === 'Group' ? node.data.h + 'px' : 'auto',
                    zIndex: node.type === 'Group' ? 0 : 2
                 }"
                 @mousedown="onNodeMouseDown(node, $event)"
                 @dragover.prevent
                 @drop.stop="onNodeDrop(node, $event)"
                 @input="markActiveDirty">
                
                <div v-if="node.type === 'Group'" class="node-header" @mousedown.left.stop="startNodeDrag(node, $event)">
                    <input v-model="node.data.label" @focus="saveSnapshot(node.data, 'label')" @change="e => { commitProp(node.data, 'label', e.target.value); markActiveDirty(); }" class="text-group-header bold" @mousedown.stop>
                </div>
                
                <div v-else class="node-header" 
                     :style="{ borderTop: '3px solid ' + getNodeHeaderColor(node) }"
                     @mousedown.left.stop="startNodeDrag(node, $event)">
                    
                    <span v-if="validationErrors[node.id]" class="icon warning-icon" :title="validationErrors[node.id].join('\n')">warning</span>

                    <span class="icon" v-html="NodeDefs[node.type]?.icon || 'extension'"></span>
                    {{ NodeDefs[node.type]?.name || node.type }}
                    
                    <div class="grow"></div>
                    <span v-if="node.type !== 'Start'" class="icon" style="font-size:14px; cursor:pointer;" @click.stop="deleteNode(node.id)">close</span>
                </div>

                <div v-if="node.type !== 'Group'" class="node-body">
                     <ui-renderer v-if="NodeDefs[node.type]" :ui="NodeDefs[node.type].ui" :node="node" :data="node.data" />
                </div>
            </div>
        </div>

        <div v-if="ui.contextMenu.visible" class="context-menu" :style="{ left: ui.contextMenu.x + 'px', top: ui.contextMenu.y + 'px' }" @mousedown.stop @wheel.stop>
            <template v-if="ui.contextMenu.type === 'canvas'">
                <input v-model="ui.searchQuery" ref="ctxSearch" class="ctx-search" placeholder="Search nodes..." @keydown.stop="onCtxKeyDown">
                <div style="overflow-y:auto; max-height:250px">
                    <div v-for="(group, gName) in filteredMenuItems" :key="gName">
                        <div class="ctx-group-label" v-if="group.items.length > 0">{{ group.label }}</div>
                        <div v-for="item in group.items" :key="item.type" 
                             class="context-item" 
                             :class="{ active: flatContextItems[ui.contextMenu.selectedIndex || 0]?.type === item.type }"
                             @click="addNode(item.type)">
                            <span class="icon">{{ item.icon }}</span> {{ item.label }}
                        </div>
                    </div>
                    <div v-if="Object.keys(filteredMenuItems).length === 0" style="padding:8px; text-align:center; font-size:12px; color:#666">No results</div>
                </div>
                <hr style="border-color:#444; margin:4px 0" v-if="selectedNodeIds.size > 0">
                <div class="context-item" @click="createGroup" v-if="selectedNodeIds.size > 0"><span class="icon">workspaces</span> Create Group</div>
                <div class="context-item" @click="detachFromGroup" v-if="hasGroupedNodesSelected()"><span class="icon">link_off</span> Detach from Group</div>
                <div class="context-item" @click="deleteSelected" v-if="selectedNodeIds.size > 0"><span class="icon">delete</span> Delete Selected</div>
            </template>
            <template v-if="ui.contextMenu.type === 'tree'">
                <div class="context-item" v-if="ui.contextMenu.item.type === 'folder'" @click="addFolder(ui.contextMenu.item.id)"><span class="icon">create_new_folder</span> Subfolder</div>
                <div class="context-item" v-if="ui.contextMenu.item.type === 'folder'" @click="addDialog(ui.contextMenu.item.id)"><span class="icon">add</span> New Dialog</div>
                <div class="context-item" @click="renameTreeItem(ui.contextMenu.item)"><span class="icon">edit</span> Rename</div>
                <div class="context-item" @click="deleteTreeItem(ui.contextMenu.item)"><span class="icon">delete</span> Delete</div>
            </template>
        </div>

    </div>

    <div v-if="showExport" class="overlay" @mousedown.self="showExport = false">
        <div class="modal">
            <h3 style="margin:0">Editor Data</h3>
            <p class="text-sm text-muted" style="margin:5px 0 10px 0">Full project data including layout, folders, and settings. Use this to save your work.</p>
            <div class="flex gap-sm">
                 <button class="primary grow" @click="copyToClipboard('project')">Copy Project JSON</button>
                 <button class="grow" @click="downloadFile('project')">Download File</button>
            </div>
            <button class="full-width mt-2" @click="triggerImport">Load Project File</button>
            
            <hr style="border-color: var(--border); width:100%; margin: 15px 0;">
            
            <h3 style="margin:0">Runtime Export</h3>
            <p class="text-sm text-muted" style="margin:5px 0 10px 0">Optimized JSON for game engines. Visuals and folders are stripped. Text is extracted to a localization map.</p>
            <div class="flex gap-sm">
                 <button class="primary grow" @click="copyToClipboard('runtime')">Copy Runtime JSON</button>
                 <button class="grow" @click="downloadFile('runtime')">Download File</button>
            </div>

            <hr style="border-color: var(--border); width:100%; margin: 15px 0;">
            
            <h3 style="margin:0">Voice Script (CSV)</h3>
            <p class="text-sm text-muted" style="margin:5px 0 10px 0">Spreadsheet format for voice actors. Includes text, notes, characters, and IDs.</p>
            <div class="flex gap-sm">
                 <button class="primary grow" @click="downloadFile('csv')">Download Voice Script CSV</button>
            </div>

            <hr style="border-color: var(--border); width:100%; margin: 15px 0;">
            
            <h3 style="margin:0">Translation / Localization</h3>
            <p class="text-sm text-muted" style="margin:5px 0 10px 0">Export standard CSV for translators.</p>
            
            <div class="flex gap-sm col mb-2">
                <div class="flex gap-sm center">
                    <label class="text-sm" style="width:100px">Base Lang:</label>
                    <select v-model="loc.baseLang" class="text-sm grow">
                        <option v-for="l in project.settings.languages" :value="l">{{ l }}</option>
                    </select>
                </div>
                <div class="flex gap-sm center">
                    <label class="text-sm" style="width:100px">Target Langs:</label>
                    <div class="flex wrap gap-sm grow">
                        <div v-for="l in project.settings.languages" :key="l" class="flex center">
                            <input type="checkbox" :value="l" v-model="loc.targetLangs" :id="'chk-'+l">
                            <label :for="'chk-'+l" class="text-sm ml-2">{{ l }}</label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="flex gap-sm">
                 <button class="primary grow" @click="exportLocalization">Export Translation CSV</button>
            </div>
            
            <div class="flex center mt-3 mb-3" style="border-top:1px solid #333;"></div>
            
            <p class="text-sm text-muted" style="margin:0 0 5px 0">Import Translation CSV:</p>
            <button class="full-width" @click="triggerLocImport">Import Translation File</button>
            <input type="file" id="locInput" style="display:none" @change="handleLocUpload" accept=".csv">

        </div>
    </div>
    <input type="file" id="fileInput" style="display:none" @change="handleFileUpload">

</div>

<script>
const { createApp, ref, reactive, computed, onMounted, nextTick, inject, provide, watch } = Vue;

// --- COMMAND PATTERN INFRASTRUCTURE ---
class Command { execute() {} undo() {} }

class CmdMoveNodes extends Command {
    constructor(nodeIdMap, nodesArray) { super(); this.nodeIdMap = JSON.parse(JSON.stringify(nodeIdMap)); this.nodesArray = nodesArray; }
    execute() { for(const id in this.nodeIdMap) { const n = this.nodesArray.find(x => x.id == id); if(n) { n.x = this.nodeIdMap[id].x; n.y = this.nodeIdMap[id].y; } } }
    undo() { for(const id in this.nodeIdMap) { const n = this.nodesArray.find(x => x.id == id); if(n) { n.x = this.nodeIdMap[id].oldX; n.y = this.nodeIdMap[id].oldY; } } }
}

class CmdAddNode extends Command {
    constructor(nodeList, node) { super(); this.nodeList = nodeList; this.node = node; }
    execute() { this.nodeList.push(this.node); }
    undo() { const idx = this.nodeList.findIndex(n => n.id === this.node.id); if(idx > -1) this.nodeList.splice(idx, 1); }
}

class CmdDeleteNode extends Command {
    constructor(nodeList, connList, nodeId) { super(); this.nodeList = nodeList; this.connList = connList; this.nodeId = nodeId; this.node = null; this.connections = []; }
    execute() {
        this.node = this.nodeList.find(n => n.id === this.nodeId);
        if(!this.node) return;
        this.connections = this.connList.filter(c => c.fromNode === this.nodeId || c.toNode === this.nodeId);
        const nIdx = this.nodeList.indexOf(this.node); if(nIdx > -1) this.nodeList.splice(nIdx, 1);
        this.connections.forEach(c => { const cIdx = this.connList.indexOf(c); if(cIdx > -1) this.connList.splice(cIdx, 1); });
    }
    undo() { if(this.node) this.nodeList.push(this.node); this.connections.forEach(c => this.connList.push(c)); }
}

class CmdAddConnection extends Command {
    constructor(connList, connection) { super(); this.connList = connList; this.connection = connection; }
    execute() { this.connList.push(this.connection); }
    undo() { const idx = this.connList.findIndex(c => c.id === this.connection.id); if(idx > -1) this.connList.splice(idx, 1); }
}

class CmdDeleteConnection extends Command {
    constructor(connList, connectionId) { super(); this.connList = connList; this.connId = connectionId; this.connection = null; }
    execute() { this.connection = this.connList.find(c => c.id === this.connId); if(this.connection) { const idx = this.connList.indexOf(this.connection); this.connList.splice(idx, 1); } }
    undo() { if(this.connection) this.connList.push(this.connection); }
}

class CmdPropChange extends Command {
    constructor(targetObj, key, oldVal, newVal) { super(); this.obj = targetObj; this.key = key; this.oldVal = oldVal; this.newVal = newVal; }
    execute() { this.obj[this.key] = this.newVal; }
    undo() { this.obj[this.key] = this.oldVal; }
}

const history = reactive({
    past: [], future: [],
    execute(cmd) { cmd.execute(); this.past.push(cmd); this.future = []; },
    undo() { const cmd = this.past.pop(); if(!cmd) return; cmd.undo(); this.future.push(cmd); },
    redo() { const cmd = this.future.pop(); if(!cmd) return; cmd.execute(); this.past.push(cmd); }
});

// --- CENTRAL SOCKET TYPES & VALIDATION ---
const SocketTypes = {
    flow:   { id: 'flow',   color: '#ffffff', shape: 'circle', accepts: ['flow'] },
    bool:   { id: 'bool',   color: '#e51400', shape: 'square', accepts: ['bool'] },
    number: { id: 'number', color: '#85c1e9', shape: 'square', accepts: ['int', 'float', 'number'] },
    int:    { id: 'int',    color: '#1ba1e2', shape: 'square', accepts: ['int', 'number'] },
    float:  { id: 'float',  color: '#26c6da', shape: 'square', accepts: ['float', 'int', 'number'] },
    string: { id: 'string', color: '#f0a30a', shape: 'square', accepts: ['string'] },
    any:    { id: 'any',    color: '#4ec9b0', shape: 'square', accepts: ['bool', 'int', 'float', 'number', 'string', 'any'] } 
};

// --- CENTRAL NODE DEFINITIONS (DECLARATIVE UI) ---
const makeLogicGate = (name) => ({
    category: 'Logic', name: name + ' Gate', icon: 'hub', color: '#4FC1FF',
    initData: (ctx) => ({ inputCount: 2 }),
    ui: [
        { type: 'dynamic_sockets', model: 'inputCount', idPrefix: 'in_', dir: 'in', sockType: 'bool', labelPrefix: 'In ', showControls: true, min: 2, label: 'Inputs' },
        { type: 'row', justify: 'right', class:'mt-2', items: [ { type: 'label', text: 'True', class:'mr-2' }, { type: 'socket', id: 'out_true', dir: 'out', sockType: 'flow' } ] },
        { type: 'row', justify: 'right', class:'mt-1', items: [ { type: 'label', text: 'False', class:'mr-2' }, { type: 'socket', id: 'out_false', dir: 'out', sockType: 'flow' } ] },
        { type: 'row', justify: 'right', class:'mt-2', items: [ { type: 'label', text: 'Result', class:'mr-2 text-muted' }, { type: 'socket', id: 'out_val', dir: 'out', sockType: 'bool' } ] }
    ]
});

const makeMathNode = (name, icon) => ({
    category: 'Math', name: name, icon: icon, color: '#d7bde2',
    initData: (ctx) => ({}),
    ui: [
        { type: 'row', justify: 'left', class:'mb-1 gap-sm center', items: [
            { type: 'socket', id: 'in_A', dir: 'in', sockType: 'number' },
            { type: 'label', text: 'A' },
            { type: 'dynamic_label', text: (node, ctx) => ctx.getConnectedType(node, 'in_A') || 'int', class:'text-muted text-sm ml-2', style:'font-style:italic' }
        ]},
        { type: 'row', justify: 'left', class:'mb-1 gap-sm center', items: [
            { type: 'socket', id: 'in_B', dir: 'in', sockType: 'number' },
            { type: 'label', text: 'B' },
            { type: 'dynamic_label', text: (node, ctx) => ctx.getConnectedType(node, 'in_B') || 'int', class:'text-muted text-sm ml-2', style:'font-style:italic' }
        ]},
        { type: 'row', justify: 'right', class:'mt-2 gap-sm center', items: [
            { type: 'dynamic_label', text: (node, ctx) => {
                const tA = ctx.getConnectedType(node, 'in_A') || 'int';
                const tB = ctx.getConnectedType(node, 'in_B') || 'int';
                return (tA === 'float' || tB === 'float') ? 'float' : 'int';
            }, class:'text-muted text-sm mr-2', style:'font-style:italic' },
            { type: 'label', text: 'Result', class:'mr-2' },
            { type: 'socket', id: 'out_val', dir: 'out', sockType: (node, ctx) => {
                const tA = ctx.getConnectedType(node, 'in_A') || 'int';
                const tB = ctx.getConnectedType(node, 'in_B') || 'int';
                return (tA === 'float' || tB === 'float') ? 'float' : 'int';
            }}
        ]}
    ]
});

const NodeDefs = {
    Start: {
        category: 'Flow', name: 'Start', icon: 'play_arrow', color: '#569cd6',
        initData: (ctx) => ({}),
        ui: [ { type: 'row', justify: 'right', items: [ { type: 'label', text: 'Start', class: 'mr-2' }, { type: 'socket', id: 'out', dir: 'out', sockType: 'flow' } ] } ]
    },
    End: {
        category: 'Flow', name: 'End / Switch', icon: 'stop', color: '#d16969',
        initData: (ctx) => ({ nextDialogId: null }),
        ui: [
            { type: 'row', justify: 'left', items: [ { type: 'socket', id: 'in', dir: 'in', sockType: 'flow' }, { type: 'label', text: 'End', class: 'ml-2' } ] },
            { type: 'label', text: 'Next Dialog', class: 'text-muted text-sm mt-2 mb-1', style:'display:block' },
            { type: 'dialog_select', model: 'nextDialogId' }
        ]
    },
    Text: {
        category: 'Dialogue', name: 'Text Node', icon: 'chat_bubble', color: '#ce9178',
        initData: (ctx) => ({ characterId: null, key: ctx.generateKey(), note: '', translations: ctx.initTranslations(), answers: [] }),
        ui: [
            { type: 'row', justify: 'left', items: [ { type: 'socket', id: 'in', dir: 'in', sockType: 'flow' }, { type: 'label', text: 'In', class: 'ml-2' } ] },
            { type: 'label', text: 'Character', class: 'text-muted text-sm mt-1 mb-1', style:'display:block' },
            { type: 'char_select', model: 'characterId' },
            { type: 'label', text: 'Key', class: 'text-muted text-sm mt-1 mb-1', style:'display:block' },
            { type: 'input', model: 'key', placeholder: 'Key' },
            { type: 'label', text: 'Audio Note', class: 'text-muted text-sm mt-1 mb-1', style:'display:block' },
            { type: 'input', model: 'note', placeholder: '(Optional context)' },
            { type: 'textarea_lang', model: 'translations', placeholder: 'Dialogue text...', class: 'mt-2' },
            { type: 'dynamic_list', model: 'answers', label: 'Answers', addTitle: 'Add Answer',
              emptyUi: [
                  { type: 'row', justify: 'right', items: [ { type: 'label', text: 'Next', class: 'mr-2' }, { type: 'socket', id: 'out', dir: 'out', sockType: 'flow' } ] }
              ],
              onAdd: (ctx, node) => {
                  if (node.data.answers.length === 0) ctx.removeConnectionsToSocket(node.id, 'out');
                  const ansId = Math.floor(Math.random() * 100000);
                  node.data.answers.push({ key: `${ctx.getPath()}.text.${node.id}.answers.${ansId}`, note: '', translations: ctx.initTranslations() });
              },
              onRemove: (ctx, node, idx) => {
                  ctx.removeAnswerConnections(node, idx);
                  node.data.answers.splice(idx, 1);
              },
              itemUi: [
                  { type: 'row', justify: 'left', class: 'mb-1 gap-sm center', items: [
                      { type: 'label', text: 'Key:', style: 'font-size:10px', class:'text-muted' },
                      { type: 'input', model: 'key', style: 'font-size:10px; padding:1px; background:none; border:none; color:#888; width:100%' }
                  ]},
                  { type: 'row', justify: 'left', class: 'gap-sm center', items: [
                      { type: 'socket', id: 'in_ans_cond_$index', dir: 'in', sockType: 'bool', title: 'Condition' },
                      { type: 'input_lang', model: 'translations', placeholder: 'Answer...', class: 'grow' },
                      { type: 'button', icon: 'remove', action: 'remove' },
                      { type: 'socket', id: 'out_ans_$index', dir: 'out', sockType: 'flow' }
                  ]},
                  { type: 'row', justify: 'left', class: 'mt-1 gap-sm center', items: [
                      { type: 'label', text: 'Note:', style: 'font-size:10px; min-width:30px', class:'text-muted' },
                      { type: 'input', model: 'note', style: 'font-size:11px; color:#aaa; padding:2px; background:rgba(0,0,0,0.2)', class: 'grow' }
                  ]}
              ]
            }
        ]
    },
    SetVar: {
        category: 'Variables', name: 'Set Variable', icon: 'edit', color: '#c586c0',
        initData: (ctx) => ({ variableId: null, operation: '=', value: '' }),
        ui: [
            { type: 'row', justify: 'left', class:'mb-2', items: [ { type: 'socket', id: 'in', dir: 'in', sockType: 'flow' }, { type: 'label', text: 'In', class:'ml-2' } ] },
            { type: 'var_select', model: 'variableId' },
            { type: 'set_var_logic' },
            { type: 'row', justify: 'right', class:'mt-2', items: [ { type: 'label', text: 'Out', class:'mr-2' }, { type: 'socket', id: 'out', dir: 'out', sockType: 'flow' } ] },
            { type: 'row', justify: 'right', class:'mt-2', items: [ { type: 'label', text: 'Val', class:'mr-2 text-muted' }, { type: 'socket', id: 'out_val', dir: 'out', sockType: (node, ctx) => ctx.getVarType(node.data.variableId) || 'any' } ] }
        ]
    },
    GetVar: {
        category: 'Variables', name: 'Get Variable', icon: 'data_object', color: '#4ec9b0',
        initData: (ctx) => ({ variableId: null }),
        ui: [
            { type: 'var_select', model: 'variableId' },
            { type: 'row', justify: 'right', class:'mt-2', items: [ { type: 'label', text: 'Value', class:'mr-2' }, { type: 'socket', id: 'out', dir: 'out', sockType: (node, ctx) => ctx.getVarType(node.data.variableId) || 'any' } ] }
        ]
    },
    Compare: {
        category: 'Logic', name: 'Compare', icon: 'balance', color: '#dcdcaa',
        initData: (ctx) => ({ operator: '==', compareValue: '' }),
        ui: [
            { type: 'row', justify: 'left', class:'mb-2', items: [ { type: 'socket', id: 'in', dir: 'in', sockType: 'flow' }, { type: 'label', text: 'In', class:'ml-2' } ] },
            { type: 'row', justify: 'left', class:'gap-sm center mt-2', items: [ { type: 'socket', id: 'in_val', dir: 'in', sockType: 'any' }, { type: 'dynamic_label', text: (node, ctx) => ctx.getConnectedType(node, 'in_val') || 'any', class:'text-muted grow text-right', style:'font-style:italic' } ] },
            { type: 'compare_logic' },
            { type: 'row', justify: 'right', class:'mt-2', items: [ { type: 'label', text: 'True', class:'mr-2' }, { type: 'socket', id: 'out_true', dir: 'out', sockType: 'flow' } ] },
            { type: 'row', justify: 'right', class:'mt-1', items: [ { type: 'label', text: 'False', class:'mr-2' }, { type: 'socket', id: 'out_false', dir: 'out', sockType: 'flow' } ] },
            { type: 'row', justify: 'right', class:'mt-2', items: [ { type: 'label', text: 'Result', class:'mr-2 text-muted' }, { type: 'socket', id: 'out_val', dir: 'out', sockType: 'bool' } ] }
        ]
    },
    FireEvent: {
        category: 'Events', name: 'Fire Event', icon: 'bolt', color: '#C586C0',
        initData: (ctx) => ({ eventName: '', inputCount: 0 }),
        ui: [
            { type: 'row', justify: 'left', items: [ { type: 'socket', id: 'in', dir: 'in', sockType: 'flow' }, { type: 'label', text: 'In', class:'ml-2' } ] },
            { type: 'input', model: 'eventName', placeholder: 'Event Name', class: 'mt-2 mb-2' },
            { type: 'dynamic_sockets', model: 'inputCount', idPrefix: 'in_', dir: 'in', sockType: 'any', labelPrefix: 'Arg ', showControls: true, min: 0, label: 'Args' },
            { type: 'row', justify: 'right', class:'mt-2', items: [ { type: 'label', text: 'Out', class:'mr-2' }, { type: 'socket', id: 'out', dir: 'out', sockType: 'flow' } ] }
        ]
    },
    And: makeLogicGate('AND'),
    Or: makeLogicGate('OR'),
    XOr: makeLogicGate('XOR'),
    NAnd: makeLogicGate('NAND'),
    NOr: makeLogicGate('NOR'),
    Add: makeMathNode('Add', 'add'),
    Subtract: makeMathNode('Subtract', 'remove'),
    Multiply: makeMathNode('Multiply', 'close'),
    Divide: makeMathNode('Divide', 'percent')
};

// --- Tree Browser Component ---
const TreeBrowser = {
    name: 'TreeBrowser',
    props: ['parentId'],
    setup(props) {
        const project = inject('project');
        const activeDialogId = inject('activeDialogId');
        const validationErrors = inject('validationErrors');
        const selectDialog = inject('selectDialog');
        const setDrag = inject('setDrag');
        const onDrop = inject('onDrop');
        const openContextMenu = inject('openContextMenu');
        const expanded = inject('expandedFolderIds');

        const myFolders = computed(() => project.folders.filter(f => f.parentId === props.parentId));
        const myDialogs = computed(() => project.dialogs.filter(d => d.folderId === props.parentId));

        const toggle = (id) => expanded.has(id) ? expanded.delete(id) : expanded.add(id);
        const isOpen = (id) => expanded.has(id);
        
        return { project, activeDialogId, validationErrors, myFolders, myDialogs, toggle, isOpen, selectDialog, setDrag, onDrop, openContextMenu };
    },
    template: `
        <div style="padding-left: 2px">
            <div v-for="folder in myFolders" :key="'f'+folder.id">
                <div class="tree-row" draggable="true" @dragstart.stop="setDrag(folder.id, 'folder')" @dragover.prevent @drop.stop="onDrop(folder.id)" @contextmenu.stop.prevent="openContextMenu($event, {id: folder.id, type: 'folder'})" @click="toggle(folder.id)">
                     <span class="icon" style="font-size:16px; color: #E8BF6A">{{ isOpen(folder.id) ? 'folder_open' : 'folder' }}</span>
                     <span class="text-sm grow">{{ folder.name }}</span>
                </div>
                <div v-if="isOpen(folder.id)" class="tree-item"><tree-browser :parent-id="folder.id"></tree-browser></div>
            </div>
            <div v-for="dia in myDialogs" :key="'d'+dia.id">
                <div class="tree-row" :class="{ active: activeDialogId === dia.id }" draggable="true" @dragstart.stop="setDrag(dia.id, 'dialog')" @contextmenu.stop.prevent="openContextMenu($event, {id: dia.id, type: 'dialog'})" @click="selectDialog(dia.id)">
                     <span v-if="validationErrors[dia.id]" class="icon warning-icon" style="font-size:14px; margin-right:4px;">warning</span>
                     <span class="icon" style="font-size:16px">chat</span>
                     <span class="text-sm grow">{{ dia.name }}</span>
                </div>
            </div>
        </div>
    `
};

const app = createApp({
    components: { TreeBrowser },
    setup() {
        const project = reactive({ meta: { nextId: 0 }, settings: { languages: ['en'], currentLang: 'en' }, variables: [], characters: [], folders: [], dialogs: [] });
        const editor = reactive({ gridSize: 40, snap: true });
        const activeDialogId = ref(null); // start null
        const ui = reactive({ sections: { settings: true, vars: true, chars: true, dialogs: true }, contextMenu: { visible: false, x: 0, y: 0, type: 'canvas', item: null, selectedIndex: 0 }, overlayCollapsed: false, searchQuery: '' });
        const ctxSearch = ref(null);
        
        const propSnapshots = new Map();
        const saveSnapshot = (obj, key) => { propSnapshots.set(obj, { ...propSnapshots.get(obj), [key]: obj[key] }); };
        const commitProp = (obj, key, newVal) => {
            const snap = propSnapshots.get(obj);
            const oldVal = (snap && snap[key] !== undefined) ? snap[key] : obj[key];
            if(oldVal !== newVal) history.execute(new CmdPropChange(obj, key, oldVal, newVal));
        };

        const expandedFolderIds = reactive(new Set());
        const collapsedCharacterIds = reactive(new Set());
        provide('expandedFolderIds', expandedFolderIds);
        const toggleChar = (id) => collapsedCharacterIds.has(id) ? collapsedCharacterIds.delete(id) : collapsedCharacterIds.add(id);

        const loc = reactive({ baseLang: 'en', targetLangs: [] });
        const toastSystem = reactive({ toasts: [], isPaused: false });
        let toastIdCounter = 0;
        const addToast = (message, type = 'info') => { toastSystem.toasts.push({ id: ++toastIdCounter, message, type, expanded: false, remaining: 3000 }); };
        const removeToast = (id) => { const idx = toastSystem.toasts.findIndex(t => t.id === id); if (idx > -1) toastSystem.toasts.splice(idx, 1); };
        const getToastIcon = (type) => ({'success': 'check_circle', 'error': 'error', 'warning': 'warning'})[type] || 'info';
        const needsExpand = (msg) => msg && (msg.length > 110 || (msg.match(/\n/g) || []).length >= 3);

        const modal = reactive({ visible: false, type: 'confirm', title: '', message: '', inputValue: '', callback: null });
        const modalInput = ref(null);
        const showConfirm = (title, message, onOk) => { modal.type = 'confirm'; modal.title = title; modal.message = message; modal.callback = onOk; modal.visible = true; };
        const showPrompt = (title, initVal, onOk) => { modal.type = 'prompt'; modal.title = title; modal.message = ''; modal.inputValue = initVal; modal.callback = onOk; modal.visible = true; nextTick(() => { if(modalInput.value) modalInput.value.focus(); }); };
        const closeModal = () => { modal.visible = false; modal.callback = null; };
        const confirmModal = () => { if (modal.callback) { if (modal.type === 'prompt') modal.callback(modal.inputValue); else modal.callback(); } closeModal(); };

        const selectedNodeIds = reactive(new Set()); 
        const hoverGroupId = ref(null); 
        const removeGroupId = ref(null); 
        const isDraggingNode = ref(false);
        const dragStartPos = { x: 0, y: 0 }; 
        const cachedNodeSizes = {}; 
        const initialNodePositions = {}; 
        const dragState = reactive({ id: null, type: null });

        const selectionRect = reactive({ visible: false, x: 0, y: 0, w: 0, h: 0, startX: 0, startY: 0 });
        const isSelecting = ref(false);
        const initialSelectionSnapshot = new Set();
        const boxSelectCache = []; 

        provide('project', project);
        provide('activeDialogId', activeDialogId);
        
        const selectDialog = (id) => {
            activeDialogId.value = id; selectedNodeIds.clear(); history.past = []; history.future = [];
            nextTick(() => { setTimeout(() => { updateTick.value++; fitView(); markDialogDirty(id); }, 20); });
        };
        provide('selectDialog', selectDialog);
        const setDrag = (id, type) => { dragState.id = id; dragState.type = type; };
        provide('setDrag', setDrag);
        
        const handleDrop = (targetFolderId) => {
            if (!dragState.id) return;
            if (dragState.type === 'folder') {
                if (dragState.id === targetFolderId) { dragState.id = null; dragState.type = null; return; }
                let check = targetFolderId;
                while(check !== null) { const f = project.folders.find(it => it.id === check); if(f && f.id === dragState.id) { dragState.id = null; dragState.type = null; return; } check = f ? f.parentId : null; }
                const folder = project.folders.find(f => f.id === dragState.id); if (folder) folder.parentId = targetFolderId;
            } else if (dragState.type === 'dialog') { const dia = project.dialogs.find(d => d.id === dragState.id); if (dia) dia.folderId = targetFolderId; }
            dragState.id = null;
            dragState.type = null;
        };
        provide('onDrop', handleDrop);
        provide('openContextMenu', (e, item) => { ui.contextMenu = { visible: true, x: e.clientX, y: e.clientY, type: 'tree', item, selectedIndex: 0 }; });

        const canvasRef = ref(null);
        const pan = reactive({ x: 0, y: 0 });
        const zoom = ref(1);
        const isPanning = ref(false);
        const selectedNodeId = ref(null);
        const selectedConnectionId = ref(null);
        const dragItem = ref(null);
        const updateTick = ref(0); 
        const isConnecting = ref(false);
        const connStart = reactive({ nodeId: null, socket: null, sockType: null, isInput: false });
        const mousePos = reactive({ x: 0, y: 0 }); 
        const lastMouseScreen = reactive({ x: window.innerWidth / 2, y: window.innerHeight / 2 });

        const showExport = ref(false); 
        const importData = ref('');
        const newLang = ref('');

        const activeDialog = computed(() => project.dialogs.find(d => d.id === activeDialogId.value));
        const activeNodes = computed(() => activeDialog.value ? activeDialog.value.nodes : []);
        const activeConnections = computed(() => activeDialog.value ? activeDialog.value.connections : []);

        const validationErrors = reactive({});
        const dirtyScopes = reactive({ full: false, dialogs: new Set() });
        const setError = (id, msgs) => { if (!msgs || msgs.length === 0) delete validationErrors[id]; else validationErrors[id] = msgs; };

        const validateVars = () => {
            const varNames = new Set();
            project.variables.forEach(v => { const errs = []; if(!v.name || v.name.trim() === '') errs.push("Variable name cannot be empty."); if(varNames.has(v.name)) errs.push("Duplicate variable name."); varNames.add(v.name); setError(v.id, errs); });
            markAllDirty();
        };

        const validateChars = () => {
            const charNames = new Set();
            project.characters.forEach(c => {
                 const errs = []; let hasError = false;
                 if(!c.name || c.name.trim() === '') { errs.push("Character name cannot be empty."); hasError = true; }
                 if(charNames.has(c.name)) { errs.push("Duplicate character name."); hasError = true; } charNames.add(c.name);
                 if (c.variables) {
                     const cVarNames = new Set();
                     c.variables.forEach(cv => { const cvErrs = []; if(!cv.name || cv.name.trim() === '') cvErrs.push("Variable name cannot be empty."); if(cVarNames.has(cv.name)) cvErrs.push("Duplicate variable name."); cVarNames.add(cv.name); setError(cv.id, cvErrs); if(cvErrs.length > 0) hasError = true; });
                 }
                 if(hasError) errs.push("Contains errors."); setError(c.id, errs);
            });
        };

        const validateDialog = (dialog) => {
            if (!dialog) return;
            if(dialog.variables) {
                const dVarNames = new Set();
                dialog.variables.forEach(v => { const vErrs = []; if(!v.name || v.name.trim() === '') vErrs.push("Variable name cannot be empty."); if(dVarNames.has(v.name)) vErrs.push("Duplicate variable name."); dVarNames.add(v.name); setError(v.id, vErrs); });
            }
            const conns = dialog.connections;
            const isConnected = (nodeId, socket) => conns.some(c => (c.fromNode === nodeId && c.fromSocket === socket) || (c.toNode === nodeId && c.toSocket === socket));
            let dialogHasErrors = false;
            dialog.nodes.forEach(node => {
                const errs = [];
                if(node.type === 'Text') {
                     if(!node.data.key) errs.push("Missing Localization Key.");
                     project.settings.languages.forEach(lang => { if(!node.data.translations[lang]) errs.push(`Missing '${lang}' translation.`); });
                     if(!isConnected(node.id, 'in')) errs.push("Flow Input disconnected.");
                     if(node.data.answers.length === 0) { if(!isConnected(node.id, 'out')) errs.push("Flow Output disconnected."); } 
                     else { node.data.answers.forEach((ans, idx) => { project.settings.languages.forEach(lang => { if(!ans.translations[lang]) errs.push(`Answer ${idx+1} missing '${lang}'.`); }); if(!isConnected(node.id, 'out_ans_'+idx)) errs.push(`Answer ${idx+1} flow disconnected.`); }); }
                } 
                else if (node.type === 'SetVar') { if(!node.data.variableId) errs.push("No Variable selected."); if(!isConnected(node.id, 'in')) errs.push("Input disconnected."); if(!isConnected(node.id, 'out')) errs.push("Output disconnected."); }
                else if (node.type === 'GetVar') { if(!node.data.variableId) errs.push("No Variable selected."); if(!isConnected(node.id, 'out')) errs.push("Value Output unused."); }
                else if (node.type === 'Compare') { if(!isConnected(node.id, 'in')) errs.push("Input disconnected."); if(!isConnected(node.id, 'in_val')) errs.push("Data Input disconnected."); if(!isConnected(node.id, 'out_true') && !isConnected(node.id, 'out_false')) errs.push("Both outputs disconnected."); }
                else if (node.type === 'Start') { if(!isConnected(node.id, 'out')) errs.push("Start node disconnected."); }
                else if (node.type === 'End') { if(!isConnected(node.id, 'in')) errs.push("End node unreachable."); }
                else if (node.type === 'FireEvent') { if(!node.data.eventName) errs.push("Missing Event Name."); if(!isConnected(node.id, 'in')) errs.push("Input disconnected."); if(!isConnected(node.id, 'out')) errs.push("Output disconnected."); }
                setError(node.id, errs); if (errs.length > 0) dialogHasErrors = true;
            });
            setError(dialog.id, dialogHasErrors ? ["Dialog contains errors."] : []);
        };

        const validateAll = () => { validateVars(); validateChars(); project.dialogs.forEach(d => validateDialog(d)); };
        const markDialogDirty = (id) => dirtyScopes.dialogs.add(id);
        const markActiveDirty = () => { if(activeDialogId.value) markDialogDirty(activeDialogId.value); };
        const markAllDirty = () => dirtyScopes.full = true;
        provide('markActiveDirty', markActiveDirty);

        const recalcGroupBounds = (useCache = false) => {
            const d = activeDialog.value; if (!d) return; const groups = d.nodes.filter(n => n.type === 'Group');
            groups.forEach(g => {
                const children = d.nodes.filter(n => n.groupId === g.id); if (children.length === 0) return;
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                children.forEach(n => {
                    if (n.x < minX) minX = n.x; if (n.y < minY) minY = n.y;
                    let w = 240, h = 200;
                    if (useCache && cachedNodeSizes[n.id]) { w = cachedNodeSizes[n.id].w; h = cachedNodeSizes[n.id].h; } 
                    else { const el = document.getElementById('node-' + n.id); if(el) { w = el.offsetWidth; h = el.offsetHeight; } else if(n.data.answers) h = 200 + n.data.answers.length * 35; }
                    if (n.x + w > maxX) maxX = n.x + w; if (n.y + h > maxY) maxY = n.y + h;
                });
                const padding = 20; const headerOffset = 45; g.x = minX - padding; g.y = minY - padding - headerOffset; g.data.w = (maxX - minX) + (padding * 2); g.data.h = (maxY - minY) + (padding * 2) + headerOffset;
            });
        };

        const updateGraph = () => {
            nextTick(() => { updateTick.value++; recalcGroupBounds(); });
        };
        provide('updateGraph', updateGraph);

        watch(updateTick, () => {
            if (dirtyScopes.full) { validateAll(); dirtyScopes.full = false; dirtyScopes.dialogs.clear(); } 
            else if (dirtyScopes.dialogs.size > 0) { dirtyScopes.dialogs.forEach(id => { const d = project.dialogs.find(dia => dia.id === id); if(d) validateDialog(d); }); dirtyScopes.dialogs.clear(); }
        });
        provide('validationErrors', validationErrors);

        let resizeObserver = null;
        onMounted(() => {
            if(canvasRef.value) canvasRef.value.addEventListener('contextmenu', onContextMenu);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('mousemove', (e) => { lastMouseScreen.x = e.clientX; lastMouseScreen.y = e.clientY; });
            validateAll(); setTimeout(() => { updateGraph(); fitView(); }, 100);
            setInterval(() => { if (toastSystem.isPaused) return; for (let i = toastSystem.toasts.length - 1; i >= 0; i--) { toastSystem.toasts[i].remaining -= 100; if (toastSystem.toasts[i].remaining <= 0) toastSystem.toasts.splice(i, 1); } }, 100);
            resizeObserver = new ResizeObserver(() => { if(!isDraggingNode.value) recalcGroupBounds(); });
            const obsLoop = () => { if (activeNodes.value) { activeNodes.value.forEach(n => { if (n.type !== 'Group') { const el = document.getElementById('node-' + n.id); if (el) resizeObserver.observe(el); } }); } };
            setInterval(obsLoop, 2000); 
        });

        const onKeyDown = (e) => {
            if (e.ctrlKey && e.code === 'Space') {
                e.preventDefault();
                if (ui.contextMenu.visible) {
                    ui.contextMenu.visible = false;
                } else {
                    if (!activeDialog.value) return;
                    const rect = canvasRef.value.getBoundingClientRect();
                    let mx = lastMouseScreen.x;
                    let my = lastMouseScreen.y;
                    if (mx >= rect.left && mx <= rect.right && my >= rect.top && my <= rect.bottom) {
                        ui.contextMenu = { visible: true, x: mx, y: my, type: 'canvas', item: null, selectedIndex: 0 };
                    } else {
                        ui.contextMenu = { visible: true, x: rect.left + rect.width / 2, y: rect.top + rect.height / 2, type: 'canvas', item: null, selectedIndex: 0 };
                    }
                    ui.searchQuery = '';
                    nextTick(() => { if(ctxSearch.value) ctxSearch.value.focus(); });
                }
                return;
            }

            if(modal.visible || !activeDialog.value) return; 
            if(['INPUT','TEXTAREA','SELECT'].includes(document.activeElement.tagName) && document.activeElement !== ctxSearch.value) return;
            if (e.ctrlKey && e.key === 'z') { e.preventDefault(); history.undo(); return; }
            if (e.ctrlKey && e.key === 'y') { e.preventDefault(); history.redo(); return; }
            if (e.ctrlKey && e.key === 'r') { e.preventDefault(); fitView(); return; }
            if ((e.key === 'Delete' || e.key === 'Backspace') && document.activeElement !== ctxSearch.value) {
                if (selectedConnectionId.value) { history.execute(new CmdDeleteConnection(activeConnections.value, selectedConnectionId.value)); selectedConnectionId.value = null; markActiveDirty(); } 
                else if (selectedNodeIds.size > 0) deleteSelected();
            }
        };

        const getUniqueId = () => ++project.meta.nextId;
        const sanitize = (str) => str.toLowerCase().replace(/[^a-z0-9]/g, '-');
        const getDialogPath = (dialogId) => {
            const dialog = project.dialogs.find(d => d.id === dialogId); if (!dialog) return '';
            const parts = []; let currentFolderId = dialog.folderId; let safety = 0;
            while (currentFolderId !== null && safety < 50) { const folder = project.folders.find(f => f.id === currentFolderId); if (folder) { parts.unshift(sanitize(folder.name)); currentFolderId = folder.parentId; } else { currentFolderId = null; } safety++; }
            parts.push(sanitize(dialog.name)); return parts.join('.');
        };

        const addFolder = (parentId) => { project.folders.push({ id: getUniqueId(), name: 'New Folder', parentId }); ui.contextMenu.visible = false; };
        const addDialog = (folderId) => {
            const id = getUniqueId();
            project.dialogs.push({ id, folderId, name: 'Dialog ' + id, variables: [], nodes: [{ id: getUniqueId(), type: 'Start', x: 50, y: 50, data: {} }, { id: getUniqueId(), type: 'End', x: 400, y: 50, data: { nextDialogId: null } }], connections: [] });
            selectDialog(id); ui.contextMenu.visible = false;
        };
        const renameTreeItem = (item) => {
            const currentName = item.type === 'dialog' ? project.dialogs.find(d=>d.id===item.id).name : project.folders.find(f=>f.id===item.id).name;
            showPrompt('Rename Item', currentName, (newName) => { if (newName) { if(item.type === 'dialog') project.dialogs.find(d=>d.id===item.id).name = newName; else project.folders.find(f=>f.id===item.id).name = newName; } });
            ui.contextMenu.visible = false;
        };
        const deleteTreeItem = (item) => {
            showConfirm('Delete Item?', 'Are you sure? Folder contents will be moved to the parent.', () => {
                if(item.type === 'dialog') { const idx = project.dialogs.findIndex(d => d.id === item.id); if(idx > -1) { project.dialogs.splice(idx, 1); if(activeDialogId.value === item.id && project.dialogs.length > 0) selectDialog(project.dialogs[0].id); else activeDialogId.value = null; } } 
                else { const folder = project.folders.find(f => f.id === item.id); if(folder) { const parent = folder.parentId; project.folders.filter(f => f.parentId === item.id).forEach(f => f.parentId = parent); project.dialogs.filter(d => d.folderId === item.id).forEach(d => d.folderId = parent); const idx = project.folders.indexOf(folder); project.folders.splice(idx, 1); } }
            });
            ui.contextMenu.visible = false;
        };

        const getRelativeOffset = (childId, parentId) => {
            const child = document.getElementById(childId); const parent = document.getElementById(parentId); if (!child || !parent) return { x: 0, y: 0 };
            let el = child, x = 0, y = 0; while (el && el !== parent && el !== document.body) { x += el.offsetLeft; y += el.offsetTop; el = el.offsetParent; } return { x: x + child.offsetWidth / 2, y: y + child.offsetHeight / 2 };
        };
        
        const getSocketPos = (nodeId, socketName) => {
            const _ = updateTick.value; const node = activeNodes.value.find(n => n.id === nodeId); if (!node) return { x: 0, y: 0 };
            const socketId = 'soc-' + nodeId + '-' + socketName; const nodeIdStr = 'node-' + nodeId;
            const offset = getRelativeOffset(socketId, nodeIdStr);
            if (offset.x === 0 && offset.y === 0) return { x: node.x + (socketName.includes('in') ? 0 : 200), y: node.y + 40 };
            return { x: node.x + offset.x, y: node.y + offset.y };
        };
        
        const dragLinePath = computed(() => {
            if (!isConnecting.value) return null;
            const startPos = getSocketPos(connStart.nodeId, connStart.socket);
            let sx = startPos.x, sy = startPos.y, ex = mousePos.x, ey = mousePos.y;
            const isLeft = connStart.socket.includes('in'); const dist = Math.abs(sx - ex) * 0.5;
            return `M ${sx} ${sy} C ${sx - (isLeft?dist:-dist)} ${sy}, ${ex + (isLeft?dist:-dist)} ${ey}, ${ex} ${ey}`;
        });
        
        const screenToWorld = (sx, sy) => ({ x: (sx - pan.x) / zoom.value, y: (sy - pan.y) / zoom.value });

        const onNodeMouseDown = (node, e) => {
            selectedConnectionId.value = null;
            if (e.ctrlKey || e.shiftKey) { if (selectedNodeIds.has(node.id)) selectedNodeIds.delete(node.id); else selectedNodeIds.add(node.id); } 
            else { if (!selectedNodeIds.has(node.id)) { selectedNodeIds.clear(); selectedNodeIds.add(node.id); } }
            selectedNodeId.value = node.id;
        };

        const onCanvasMouseDown = (e) => {
            if (ui.contextMenu.visible) ui.contextMenu.visible = false;
            if (!activeDialog.value) return; // Prevent selection logic if no dialog

            if (e.button === 0 && !e.altKey) { 
                isSelecting.value = true; selectionRect.visible = true; selectionRect.startX = e.clientX; selectionRect.startY = e.clientY; selectionRect.x = e.clientX; selectionRect.y = e.clientY; selectionRect.w = 0; selectionRect.h = 0;
                if (!e.shiftKey && !e.ctrlKey) selectedNodeIds.clear();
                initialSelectionSnapshot.clear(); selectedNodeIds.forEach(id => initialSelectionSnapshot.add(id)); selectedNodeId.value = null; selectedConnectionId.value = null;
                boxSelectCache.length = 0;
                activeNodes.value.forEach(n => { let w = 240, h = 200; if (n.type === 'Group') { w = n.data.w; h = n.data.h; } else { const el = document.getElementById('node-' + n.id); if (el) { w = el.offsetWidth; h = el.offsetHeight; } } boxSelectCache.push({ id: n.id, x: n.x, y: n.y, w, h }); });
            } else if (e.button === 1) startPan(e);
        };

        const createGroup = () => {
            if (selectedNodeIds.size === 0) return; const ids = Array.from(selectedNodeIds); const nodes = activeNodes.value.filter(n => ids.includes(n.id) && n.type !== 'Group'); if (nodes.length === 0) return;
            const groupId = getUniqueId(); const groupNode = { id: groupId, type: 'Group', x: 0, y: 0, data: { label: 'Group ' + groupId, w: 100, h: 100 } };
            history.execute(new CmdAddNode(activeNodes.value, groupNode));
            nodes.forEach(n => n.groupId = groupId); selectedNodeIds.clear(); updateGraph(); ui.contextMenu.visible = false;
        };

        const hasGroupedNodesSelected = () => { for (let id of selectedNodeIds) { const node = activeNodes.value.find(n => n.id === id); if (node && node.groupId) return true; } return false; };
        const detachFromGroup = () => { selectedNodeIds.forEach(id => { const node = activeNodes.value.find(n => n.id === id); if(node && node.groupId) node.groupId = null; }); updateGraph(); ui.contextMenu.visible = false; };

        const startNodeDrag = (node, e) => {
            isDraggingNode.value = true; dragItem.value = node; onNodeMouseDown(node, e);
            activeNodes.value.forEach(n => { const el = document.getElementById('node-' + n.id); if(el) cachedNodeSizes[n.id] = { w: el.offsetWidth, h: el.offsetHeight }; initialNodePositions[n.id] = { x: n.x, y: n.y }; });
            dragStartPos.x = e.clientX; dragStartPos.y = e.clientY; ui.contextMenu.visible = false;
        };

        const handleMove = (e) => {
            if (!activeDialog.value) return; // Prevent move logic if no dialog

            const rect = canvasRef.value.getBoundingClientRect();
            if (isSelecting.value) {
                const currentX = e.clientX; const currentY = e.clientY;
                const left = Math.min(selectionRect.startX, currentX); const top = Math.min(selectionRect.startY, currentY); const width = Math.abs(currentX - selectionRect.startX); const height = Math.abs(currentY - selectionRect.startY);
                selectionRect.x = left; selectionRect.y = top; selectionRect.w = width; selectionRect.h = height;
                const worldLeft = (left - rect.left - pan.x) / zoom.value; const worldTop = (top - rect.top - pan.y) / zoom.value; const worldRight = worldLeft + (width / zoom.value); const worldBottom = worldTop + (height / zoom.value);
                const inSelection = new Set();
                for (const node of boxSelectCache) { if (node.x < worldRight && node.x + node.w > worldLeft && node.y < worldBottom && node.y + node.h > worldTop) inSelection.add(node.id); }
                if (e.shiftKey || e.ctrlKey) { selectedNodeIds.clear(); initialSelectionSnapshot.forEach(id => selectedNodeIds.add(id)); inSelection.forEach(id => selectedNodeIds.add(id)); } 
                else { selectedNodeIds.clear(); inSelection.forEach(id => selectedNodeIds.add(id)); }
                return; 
            }

            const wPos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top); mousePos.x = wPos.x; mousePos.y = wPos.y;

            if (isPanning.value) { pan.x += e.movementX; pan.y += e.movementY; } 
            else if (isDraggingNode.value && dragItem.value) {
                const totalDx = (e.clientX - dragStartPos.x) / zoom.value; const totalDy = (e.clientY - dragStartPos.y) / zoom.value;
                let snappedDx = totalDx; let snappedDy = totalDy;
                if (editor.snap) {
                    const s = editor.gridSize; const initDragX = initialNodePositions[dragItem.value.id].x; const initDragY = initialNodePositions[dragItem.value.id].y;
                    snappedDx = (Math.round((initDragX + totalDx) / s) * s) - initDragX; snappedDy = (Math.round((initDragY + totalDy) / s) * s) - initDragY;
                }
                const idsToMove = new Set(selectedNodeIds);
                if (dragItem.value.type === 'Group') { activeNodes.value.forEach(n => { if (n.groupId === dragItem.value.id) idsToMove.add(n.id); }); }
                idsToMove.forEach(id => { const n = activeNodes.value.find(node => node.id === id); if (n && initialNodePositions[id]) { n.x = initialNodePositions[id].x + snappedDx; n.y = initialNodePositions[id].y + snappedDy; } });
                
                hoverGroupId.value = null; removeGroupId.value = null;
                if (dragItem.value.type !== 'Group') {
                    const cx = dragItem.value.x + 120; const cy = dragItem.value.y + 100;
                    const target = activeNodes.value.find(g => g.type === 'Group' && cx > g.x && cx < g.x + g.data.w && cy > g.y && cy < g.y + g.data.h);
                    if (target) { if (dragItem.value.groupId !== target.id) hoverGroupId.value = target.id; } 
                    else if (dragItem.value.groupId) { if (e.shiftKey) removeGroupId.value = dragItem.value.groupId; else recalcGroupBounds(true); }
                }
                updateTick.value++;
            }
        };

        const handleUp = () => {
            if (isSelecting.value) { isSelecting.value = false; selectionRect.visible = false; }
            if (isDraggingNode.value && dragItem.value) {
                const movedNodesMap = {}; let hasMoved = false;
                const idsToCheck = new Set(selectedNodeIds);
                if (dragItem.value.type === 'Group') activeNodes.value.forEach(n => { if(n.groupId === dragItem.value.id) idsToCheck.add(n.id); });
                idsToCheck.forEach(id => { const n = activeNodes.value.find(x => x.id === id); const init = initialNodePositions[id]; if(n && init && (n.x !== init.x || n.y !== init.y)) { movedNodesMap[id] = { x: n.x, y: n.y, oldX: init.x, oldY: init.y }; hasMoved = true; } });
                if(hasMoved) history.execute(new CmdMoveNodes(movedNodesMap, activeNodes.value));

                if (dragItem.value.type !== 'Group') {
                    if (hoverGroupId.value) { selectedNodeIds.forEach(id => { const n = activeNodes.value.find(node => node.id === id); if (n && n.type !== 'Group') n.groupId = hoverGroupId.value; }); } 
                    else if (removeGroupId.value) { selectedNodeIds.forEach(id => { const n = activeNodes.value.find(node => node.id === id); if (n && n.type !== 'Group' && n.groupId === removeGroupId.value) n.groupId = null; }); }
                    updateGraph();
                }
            }
            isPanning.value = false; isDraggingNode.value = false; dragItem.value = null; hoverGroupId.value = null; removeGroupId.value = null; if (isConnecting.value) isConnecting.value = false;
        };

        const startPan = (e) => isPanning.value = true;
        const handleZoom = (e) => { const speed = 0.001; const delta = -e.deltaY * speed; zoom.value = Math.min(Math.max(zoom.value + delta, 0.2), 3); };
        
        const onContextMenu = (e) => { 
            e.preventDefault(); 
            if (!activeDialog.value) return; // Block context menu if no active dialog

            if (isConnecting.value) { isConnecting.value = false; return; } 
            ui.contextMenu = { visible: true, x: e.clientX, y: e.clientY, type: 'canvas', item: null, selectedIndex: 0 }; 
            ui.searchQuery = ''; 
            nextTick(() => { if(ctxSearch.value) ctxSearch.value.focus(); }); 
        };

        const fitView = () => {
            if (!activeNodes.value.length || !canvasRef.value) return;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            activeNodes.value.forEach(n => {
                if (n.x < minX) minX = n.x; if (n.y < minY) minY = n.y;
                const w = n.type === 'Group' ? n.data.w : (document.getElementById('node-'+n.id)?.offsetWidth || 240);
                const h = n.type === 'Group' ? n.data.h : (document.getElementById('node-'+n.id)?.offsetHeight || 200);
                if (n.x + w > maxX) maxX = n.x + w; if (n.y + h > maxY) maxY = n.y + h;
            });
            minX -= 50; minY -= 50; maxX += 50; maxY += 50; const graphW = maxX - minX; const graphH = maxY - minY; const rect = canvasRef.value.getBoundingClientRect(); const scaleX = rect.width / graphW; const scaleY = rect.height / graphH;
            let newZoom = Math.min(scaleX, scaleY); newZoom = Math.min(Math.max(newZoom, 0.2), 1.5); zoom.value = newZoom;
            pan.x = (rect.width - graphW * newZoom) / 2 - minX * newZoom; pan.y = (rect.height - graphH * newZoom) / 2 - minY * newZoom;
        };

        const addNode = (type) => {
            const id = getUniqueId(); const rect = canvasRef.value.getBoundingClientRect(); const wPos = screenToWorld(ui.contextMenu.x - rect.left, ui.contextMenu.y - rect.top);
            
            const localCtx = {
                ...NodeContext,
                generateKey: () => `${getDialogPath(activeDialogId.value)}.text.${id}`
            };

            const node = { id, type, x: wPos.x, y: wPos.y, data: NodeDefs[type].initData(localCtx) };
            history.execute(new CmdAddNode(activeNodes.value, node)); ui.contextMenu.visible = false; 
            updateGraph(); markActiveDirty();
        };

        const deleteNode = (id) => {
            const nodeToDelete = activeNodes.value.find(n => n.id === id);
            if (nodeToDelete && nodeToDelete.type === 'Start') {
                 addToast("The Start node cannot be deleted.", "warning");
                 return;
            }

            showConfirm("Delete Node?", "Are you sure you want to delete this node?", () => {
                if (nodeToDelete && nodeToDelete.type === 'Group') { const children = activeNodes.value.filter(n => n.groupId === id); children.forEach(c => c.groupId = null); }
                history.execute(new CmdDeleteNode(activeNodes.value, activeConnections.value, id)); updateGraph(); markActiveDirty();
            });
        };
        
        const deleteSelected = () => {
            if (selectedNodeIds.size === 0) return;

            let nodesToDelete = Array.from(selectedNodeIds);
            const hasStart = nodesToDelete.some(id => { const n = activeNodes.value.find(node => node.id === id); return n && n.type === 'Start'; });

            if (hasStart) {
                 addToast("The Start node cannot be deleted. Other nodes will be deleted.", "warning");
                 nodesToDelete = nodesToDelete.filter(id => { const n = activeNodes.value.find(node => node.id === id); return n && n.type !== 'Start'; });
                 if (nodesToDelete.length === 0) return;
            }

            showConfirm("Delete Selected?", `Delete ${nodesToDelete.length} node(s)?`, () => {
                nodesToDelete.forEach(id => { const nodeToDelete = activeNodes.value.find(n => n.id === id); if(nodeToDelete) history.execute(new CmdDeleteNode(activeNodes.value, activeConnections.value, id)); });
                selectedNodeIds.clear(); updateGraph(); markActiveDirty();
            }); ui.contextMenu.visible = false;
        };

        const startConnect = (nodeId, socket, sockType, event) => {
            isConnecting.value = true; connStart.nodeId = nodeId; connStart.socket = socket; connStart.sockType = sockType; connStart.isInput = socket.includes('in'); selectedConnectionId.value = null;
            const rect = canvasRef.value.getBoundingClientRect(); const wPos = screenToWorld(event.clientX - rect.left, event.clientY - rect.top); mousePos.x = wPos.x; mousePos.y = wPos.y;
        };
        
        const canDrop = (dir, targetSockType) => {
            if (!isConnecting.value) return false;
            if ((!connStart.isInput && dir === 'in') || (connStart.isInput && dir === 'out')) {
                const target = dir === 'in' ? targetSockType : connStart.sockType;
                const source = dir === 'in' ? connStart.sockType : targetSockType;
                return SocketTypes[target]?.accepts.includes(source) || false;
            } return false;
        };

        const finishConnect = (nodeId, socket, sockType) => {
            if (!isConnecting.value) return;
            if (connStart.nodeId === nodeId && connStart.socket === socket) { isConnecting.value = false; return; }
            let fromNode, fromSocket, toNode, toSocket;
            if (connStart.isInput) { if (socket.includes('in')) { isConnecting.value = false; return; } fromNode = nodeId; fromSocket = socket; toNode = connStart.nodeId; toSocket = connStart.socket; } 
            else { if (!socket.includes('in') && socket !== 'in_val') { isConnecting.value = false; return; } fromNode = connStart.nodeId; fromSocket = connStart.socket; toNode = nodeId; toSocket = socket; }

            const targetSocketType = connStart.isInput ? connStart.sockType : sockType;
            const sourceSocketType = connStart.isInput ? sockType : connStart.sockType;
            
            if (!SocketTypes[targetSocketType]?.accepts.includes(sourceSocketType)) { addToast(`Cannot connect ${sourceSocketType} to ${targetSocketType}.`, "error"); isConnecting.value = false; return; }

            const newConn = { id: getUniqueId(), fromNode, fromSocket, toNode, toSocket };
            if (!activeConnections.value.find(c => c.fromNode === newConn.fromNode && c.fromSocket === newConn.fromSocket && c.toNode === newConn.toNode && c.toSocket === newConn.toSocket)) {
                history.execute(new CmdAddConnection(activeConnections.value, newConn));
            }
            isConnecting.value = false; markActiveDirty(); updateGraph();
        };

        const getPath = (conn) => {
            const start = getSocketPos(conn.fromNode, conn.fromSocket); const end = getSocketPos(conn.toNode, conn.toSocket);
            const sx = start.x, sy = start.y, ex = end.x, ey = end.y, dist = Math.abs(sx - ex) * 0.5;
            return `M ${sx} ${sy} C ${sx + dist} ${sy}, ${ex - dist} ${ey}, ${ex} ${ey}`;
        };
        
        const selectConnection = (id) => { selectedConnectionId.value = id; selectedNodeIds.clear(); selectedNodeId.value = null; };

        const getVarType = (id) => {
            if (activeDialog.value && activeDialog.value.variables) { const v = activeDialog.value.variables.find(v => v.id === id); if(v) return v.type; }
            let v = project.variables.find(v => v.id === id); if(v) return v.type;
            for(const c of project.characters) { if(c.variables) { v = c.variables.find(v => v.id === id); if(v) return v.type; } }
            return null;
        };

        const getConnectedType = (node, socketId = 'in_val', visited = new Set()) => {
            if (visited.has(node.id)) return null;
            visited.add(node.id);
            const conn = activeConnections.value.find(c => c.toNode === node.id && c.toSocket === socketId);
            if (conn) { 
                const sourceNode = activeNodes.value.find(n => n.id === conn.fromNode); 
                if (sourceNode) { 
                    if (sourceNode.type === 'GetVar' || sourceNode.type === 'SetVar') return getVarType(sourceNode.data.variableId); 
                    if (['Add', 'Subtract', 'Multiply', 'Divide'].includes(sourceNode.type)) {
                        const tA = getConnectedType(sourceNode, 'in_A', visited) || 'int';
                        const tB = getConnectedType(sourceNode, 'in_B', visited) || 'int';
                        return (tA === 'float' || tB === 'float') ? 'float' : 'int';
                    }
                } 
            }
            return null;
        };

        const removeConnectionsToSocket = (nodeId, socket) => {
            const toRemove = activeConnections.value.filter(c => (c.toNode === nodeId && c.toSocket === socket) || (c.fromNode === nodeId && c.fromSocket === socket));
            toRemove.forEach(c => history.execute(new CmdDeleteConnection(activeConnections.value, c.id)));
        };

        const removeAnswerConnections = (node, idx) => {
            removeConnectionsToSocket(node.id, 'out_ans_' + idx);
            removeConnectionsToSocket(node.id, 'in_ans_cond_' + idx);
            activeConnections.value.forEach(c => {
                if(c.fromNode === node.id && c.fromSocket.startsWith('out_ans_')) { const cIdx = parseInt(c.fromSocket.replace('out_ans_', '')); if(cIdx > idx) c.fromSocket = 'out_ans_' + (cIdx - 1); }
                if(c.toNode === node.id && c.toSocket.startsWith('in_ans_cond_')) { const cIdx = parseInt(c.toSocket.replace('in_ans_cond_', '')); if(cIdx > idx) c.toSocket = 'in_ans_cond_' + (cIdx - 1); }
            });
        };

        const initTranslations = () => { const t={}; project.settings.languages.forEach(l => t[l]=''); return t; };

        const NodeContext = { getVarType, getConnectedType, getPath: () => getDialogPath(activeDialogId.value), initTranslations, activeDialog, project, SocketTypes, removeConnectionsToSocket, removeAnswerConnections, saveSnapshot, commitProp };
        provide('NodeContext', NodeContext);
        provide('canDrop', canDrop); provide('startConnect', startConnect); provide('finishConnect', finishConnect);

        const deleteDialog = (id) => { showConfirm("Delete Dialog?", "This cannot be undone.", () => { const idx = project.dialogs.findIndex(d => d.id === id); if(idx > -1) { project.dialogs.splice(idx, 1); activeDialogId.value = project.dialogs.length ? project.dialogs[0].id : null; setError(id, []); } }); };
        const addVariable = () => { project.variables.push({ id: getUniqueId(), name: 'newVar', type: 'bool', value: 'false' }); validateVars(); };
        const deleteVariable = (id) => { showConfirm("Delete Variable?", "References in nodes will break.", () => { const i = project.variables.findIndex(v=>v.id===id); if(i>-1) project.variables.splice(i,1); validateVars(); setError(id, []); }); };
        const hslToHex = (h, s, l) => { l /= 100; const a = s * Math.min(l, 1 - l) / 100; const f = n => { const k = (n + h / 30) % 12; const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1); return Math.round(255 * color).toString(16).padStart(2, '0'); }; return `#${f(0)}${f(8)}${f(4)}`; };
        const addCharacter = () => { project.characters.push({ id: getUniqueId(), name: 'New Char', color: hslToHex(Math.floor(Math.random() * 360),40 + Math.floor(Math.random() * 20),50 + Math.floor(Math.random() * 20)), description: '', variables: [] }); validateChars(); };
        const addCharacterVariable = (charId) => { const char = project.characters.find(c => c.id === charId); if(char) { if(!char.variables) char.variables = []; char.variables.push({ id: getUniqueId(), name: 'cVar', type: 'bool', value: 'false' }); validateChars(); } };
        const deleteCharacterVariable = (charId, varId) => { showConfirm("Delete Variable?", "References might break.", () => { const char = project.characters.find(c => c.id === charId); if(char && char.variables) { const idx = char.variables.findIndex(v => v.id === varId); if(idx > -1) char.variables.splice(idx, 1); validateChars(); setError(varId, []); } }); };
        const deleteCharacter = (id) => { showConfirm("Delete Character?", "Are you sure?", () => { const i = project.characters.findIndex(c=>c.id===id); if(i>-1) project.characters.splice(i,1); validateChars(); setError(id, []); }); };
        const addLang = () => { if(newLang.value && !project.settings.languages.includes(newLang.value)) { const l = newLang.value; project.settings.languages.push(l); project.dialogs.forEach(d => { d.nodes.forEach(n => { if(n.type === 'Text') { if(!n.data.translations[l]) n.data.translations[l] = ''; n.data.answers.forEach(a => { if(!a.translations[l]) a.translations[l] = ''; }); } }); }); markAllDirty(); updateGraph(); } newLang.value=''; };
        const toggle = (s) => ui.sections[s] = !ui.sections[s];

        const getNodeHeaderColor = (node) => { if (node.type === 'Text' && node.data.characterId) { const c = project.characters.find(ch => ch.id === node.data.characterId); if (c && c.color) return c.color; } return NodeDefs[node.type]?.color || '#888'; };
        const addDialogVariable = () => { if (!activeDialog.value) return; if (!activeDialog.value.variables) activeDialog.value.variables = []; activeDialog.value.variables.push({ id: getUniqueId(), name: 'local_var', type: 'bool', value: 'false', resetOnStart: true }); markActiveDirty(); };
        const deleteDialogVariable = (id) => { if (!activeDialog.value) return; showConfirm("Delete Local Variable?", "References inside this dialog will break.", () => { const idx = activeDialog.value.variables.findIndex(v => v.id === id); if (idx > -1) { activeDialog.value.variables.splice(idx, 1); markActiveDirty(); setError(id, []); } }); };

        const menuItems = Object.keys(NodeDefs)
            .filter(k => k !== 'Start')
            .map(k => ({ type: k, label: NodeDefs[k].name, icon: NodeDefs[k].icon, group: NodeDefs[k].category }));
            
        const filteredMenuItems = computed(() => { const q = ui.searchQuery.toLowerCase(); const groups = {}; menuItems.forEach(item => { if(item.label.toLowerCase().includes(q)) { if(!groups[item.group]) groups[item.group] = { label: item.group, items: [] }; groups[item.group].items.push(item); } }); return groups; });

        const flatContextItems = computed(() => {
            const items = [];
            for (const group in filteredMenuItems.value) {
                items.push(...filteredMenuItems.value[group].items);
            }
            return items;
        });

        const scrollCtx = () => {
            nextTick(() => {
                const activeEl = document.querySelector('.context-menu .context-item.active');
                if (activeEl) activeEl.scrollIntoView({ block: 'nearest' });
            });
        };

        watch(() => ui.searchQuery, () => { ui.contextMenu.selectedIndex = 0; });

        const onCtxKeyDown = (e) => {
            if (!ui.contextMenu.visible || ui.contextMenu.type !== 'canvas') return;
            const max = flatContextItems.value.length - 1;
            if (e.key === 'ArrowDown') { 
                e.preventDefault(); 
                ui.contextMenu.selectedIndex = Math.min((ui.contextMenu.selectedIndex || 0) + 1, max); 
                scrollCtx();
            } else if (e.key === 'ArrowUp') { 
                e.preventDefault(); 
                ui.contextMenu.selectedIndex = Math.max((ui.contextMenu.selectedIndex || 0) - 1, 0); 
                scrollCtx();
            } else if (e.key === 'Enter') { 
                e.preventDefault(); 
                const sel = flatContextItems.value[ui.contextMenu.selectedIndex || 0];
                if (sel) addNode(sel.type);
            }
        };

        const onCanvasDrop = (e) => {
            if (dragState.type === 'variable' && activeDialog.value) {
                const rect = canvasRef.value.getBoundingClientRect();
                const wPos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
                const id = getUniqueId();
                const localCtx = { ...NodeContext, generateKey: () => `${getDialogPath(activeDialogId.value)}.text.${id}` };
                const node = { id, type: 'GetVar', x: wPos.x, y: wPos.y, data: NodeDefs['GetVar'].initData(localCtx) };
                node.data.variableId = dragState.id;
                history.execute(new CmdAddNode(activeNodes.value, node));
                updateGraph(); markActiveDirty();
                dragState.id = null;
                dragState.type = null;
            }
        };

        const onNodeDrop = (node, e) => {
            if (dragState.type === 'variable') {
                if (node.type === 'GetVar' || node.type === 'SetVar') {
                    const oldVal = node.data.variableId;
                    const newVal = dragState.id;
                    if (oldVal !== newVal) {
                        history.execute(new CmdPropChange(node.data, 'variableId', oldVal, newVal));
                        markActiveDirty();
                    }
                }
                dragState.id = null;
                dragState.type = null;
            }
        };

        const getProjectJson = () => { project.uiState = { gridSize: editor.gridSize, snap: editor.snap, sections: ui.sections, expandedFolders: Array.from(expandedFolderIds), collapsedCharacters: Array.from(collapsedCharacterIds), overlayCollapsed: ui.overlayCollapsed }; return JSON.stringify(project, null, 2); };

        const getRuntimeJson = () => {
            const runtime = { settings: project.settings, globalVars: {}, characters: {}, dialogs: [] };
            const resolveVar = (varId, currentDialog) => {
                if (currentDialog && currentDialog.variables) { const l = currentDialog.variables.find(v => v.id === varId); if(l) return { name: l.name, scope: 'local', type: l.type }; }
                const g = project.variables.find(v => v.id === varId); if(g) return { name: g.name, scope: 'global', type: g.type };
                for(const c of project.characters) { if(c.variables) { const cv = c.variables.find(v => v.id === varId); if(cv) return { name: cv.name, scope: 'character', characterId: c.id, type: cv.type }; } } return null;
            };

            project.variables.forEach(v => runtime.globalVars[v.name] = { type: v.type, value: v.value });
            project.characters.forEach(c => { runtime.characters[c.id] = { name: c.name, variables: {} }; if (c.variables) { c.variables.forEach(cv => runtime.characters[c.id].variables[cv.name] = { type: cv.type, value: cv.value }); } });

            project.dialogs.forEach(d => {
                const dialogExport = { id: d.id, name: d.name, variables: {}, nodes: [], connections: [] };
                if (d.variables) { d.variables.forEach(v => { dialogExport.variables[v.name] = { type: v.type, value: v.value, resetOnStart: (v.resetOnStart !== undefined) ? v.resetOnStart : true }; }); }
                const cleanNodes = d.nodes.filter(n => n.type !== 'Group').map(n => {
                    const clean = { id: n.id, type: n.type };
                    if (n.type === 'Text') {
                        clean.characterId = n.data.characterId; clean.textKey = n.data.key; clean.translations = {}; project.settings.languages.forEach(lang => { clean.translations[lang] = n.data.translations[lang] || ''; });
                        clean.choices = n.data.answers.map((a, idx) => {
                             const choiceObj = { id: 'out_ans_' + idx, textKey: a.key, translations: {} }; project.settings.languages.forEach(lang => { choiceObj.translations[lang] = a.translations[lang] || ''; });
                             const condConn = d.connections.find(c => c.toNode === n.id && c.toSocket === 'in_ans_cond_' + idx); if (condConn) choiceObj.conditionNodeId = condConn.fromNode; 
                             return choiceObj;
                        });
                    }
                    else if (n.type === 'Compare') { const conn = d.connections.find(c => c.toNode === n.id && c.toSocket === 'in_val'); if (conn) { const source = d.nodes.find(sn => sn.id === conn.fromNode); if (source && (source.type === 'GetVar' || source.type === 'SetVar')) { const varInfo = resolveVar(source.data.variableId, d); if (varInfo) clean.variable = varInfo; } } clean.operator = n.data.operator; clean.value = n.data.compareValue; }
                    else if (['And','NAnd','Or','NOr','XOr'].includes(n.type)) { clean.inputs = []; for(let i=0; i<n.data.inputCount; i++) { const conn = d.connections.find(c => c.toNode === n.id && c.toSocket === 'in_' + i); clean.inputs.push(conn ? conn.fromNode : null); } }
                    else if (['Add', 'Subtract', 'Multiply', 'Divide'].includes(n.type)) {
                        const connA = d.connections.find(c => c.toNode === n.id && c.toSocket === 'in_A'); const connB = d.connections.find(c => c.toNode === n.id && c.toSocket === 'in_B');
                        clean.a = connA ? connA.fromNode : null; clean.b = connB ? connB.fromNode : null;
                    }
                    else if (n.type === 'FireEvent') { clean.eventName = n.data.eventName; clean.args = []; for(let i=0; i<n.data.inputCount; i++) { const conn = d.connections.find(c => c.toNode === n.id && c.toSocket === 'in_' + i); clean.args.push(conn ? conn.fromNode : null); } }
                    else if (n.type === 'SetVar') { 
                        const varInfo = resolveVar(n.data.variableId, d); if (varInfo) clean.variable = varInfo; clean.operation = n.data.operation; clean.value = n.data.value; 
                        const conn = d.connections.find(c => c.toNode === n.id && c.toSocket === 'in_val'); if(conn) clean.inputNode = conn.fromNode;
                    }
                    else if (n.type === 'GetVar') { const varInfo = resolveVar(n.data.variableId, d); if (varInfo) clean.variable = varInfo; }
                    else if (n.type === 'End') { clean.nextDialogId = n.data.nextDialogId; }
                    return clean;
                });
                dialogExport.nodes = cleanNodes;
                dialogExport.connections = d.connections.map(c => ({ id: c.id, from: c.fromNode, fromSocket: c.fromSocket, to: c.toNode, toSocket: c.toSocket }));
                runtime.dialogs.push(dialogExport);
            }); return JSON.stringify(runtime, null, 2);
        };

        const getCsvData = (headers, rows) => rows.map(r => r.map(field => { const str = String(field || ''); if (str.includes(',') || str.includes('"') || str.includes('\n')) { return `"${str.replace(/"/g, '""')}"`; } return str; }).join(',')).join('\n');

        const getVoiceScriptData = () => {
            const headers = ['Dialog', 'ID', 'Type', 'Character', 'Audio Note', ...project.settings.languages]; const rows = [headers];
            project.dialogs.forEach(d => { d.nodes.filter(n => n.type === 'Text').forEach(n => {
                    let charName = "Narrator"; if (n.data.characterId) { const c = project.characters.find(ch => ch.id === n.data.characterId); if (c) charName = c.name; }
                    const row = [d.name, n.data.key, "Line", charName, n.data.note || '']; project.settings.languages.forEach(lang => row.push(n.data.translations[lang] || '')); rows.push(row);
                    n.data.answers.forEach(ans => { const ansRow = [d.name, ans.key, "Choice", "Player", ans.note || '']; project.settings.languages.forEach(lang => ansRow.push(ans.translations[lang] || '')); rows.push(ansRow); });
            }); }); return getCsvData(headers, rows);
        };

        const exportLocalization = () => {
            if(!loc.targetLangs.length) { addToast("Please select at least one target language.", "warning"); return; }
            const headers = ['Key', 'Type', 'Character', 'Context/Description', 'Audio Note', `Source [${loc.baseLang}]`]; loc.targetLangs.forEach(l => headers.push(`Target [${l}]`)); const rows = [headers];
            project.dialogs.forEach(d => { d.nodes.filter(n => n.type === 'Text').forEach(n => {
                    let charName = "Narrator"; let charDesc = ""; if (n.data.characterId) { const c = project.characters.find(ch => ch.id === n.data.characterId); if (c) { charName = c.name; charDesc = c.description || ''; } }
                    const row = [ n.data.key, "Line", charName, charDesc, n.data.note || '', n.data.translations[loc.baseLang] || '' ]; loc.targetLangs.forEach(l => row.push(n.data.translations[l] || '')); rows.push(row);
                    n.data.answers.forEach(ans => { const ansRow = [ ans.key, "Choice", "Player", "Player Selection", ans.note || '', ans.translations[loc.baseLang] || '' ]; loc.targetLangs.forEach(l => ansRow.push(ans.translations[l] || '')); rows.push(ansRow); });
            }); });
            const blob = new Blob([getCsvData(headers, rows)], { type: 'text/csv' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `localization_export_${Date.now()}.csv`; a.click();
        };

        const copyToClipboard = (mode) => { navigator.clipboard.writeText(mode === 'runtime' ? getRuntimeJson() : getProjectJson()).then(() => { addToast(mode === 'runtime' ? "Runtime JSON copied!" : "Project JSON copied!", "success"); }); };
        const downloadFile = (mode) => {
            let data, type, ext, prefix; if (mode === 'csv') { data = getVoiceScriptData(); type = 'text/csv'; ext = 'csv'; prefix = 'voice_script'; } else { data = mode === 'runtime' ? getRuntimeJson() : getProjectJson(); type = 'application/json'; ext = 'json'; prefix = mode === 'runtime' ? 'dialog_runtime' : 'dialog_project'; }
            const blob = new Blob([data], { type }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `${prefix}_${Date.now()}.${ext}`; a.click();
        };

        const triggerImport = () => document.getElementById('fileInput').click();
        const triggerLocImport = () => document.getElementById('locInput').click();
        const handleFileUpload = (e) => { const f = e.target.files[0]; if(!f) return; const r = new FileReader(); r.onload = (evt) => { importData.value = evt.target.result; processImport(); }; r.readAsText(f); };
        const handleLocUpload = (e) => { const f = e.target.files[0]; if(!f) return; const r = new FileReader(); r.onload = (evt) => { processLocImport(evt.target.result); }; r.readAsText(f); e.target.value = ''; };

        const parseCSV = (str) => {
            const arr = []; let quote = false; let col = 0, row = 0;
            for (let c = 0; c < str.length; c++) {
                let cc = str[c], nc = str[c+1]; if (!arr[row]) arr[row] = []; if (!arr[row][col]) arr[row][col] = '';
                if (cc === '"' && quote && nc === '"') { arr[row][col] += '"'; ++c; continue; } if (cc === '"') { quote = !quote; continue; } if (cc === ',' && !quote) { ++col; continue; }
                if (cc === '\r' && nc === '\n' && !quote) { ++row; col = 0; ++c; continue; } if (cc === '\n' && !quote) { ++row; col = 0; continue; } if (cc === '\r' && !quote) { ++row; col = 0; continue; }
                arr[row][col] += cc;
            } return arr;
        };

        const processLocImport = (csvText) => {
            try {
                const rows = parseCSV(csvText); if(rows.length < 2) throw new Error("Empty or invalid CSV");
                const headers = rows[0]; const keyIdx = headers.findIndex(h => h.trim().toLowerCase() === 'key'); if(keyIdx === -1) throw new Error("Missing 'Key' column");
                const langMap = {}; headers.forEach((h, idx) => { const match = h.match(/Target \[(.+)\]/i); if(match && match[1] && project.settings.languages.includes(match[1])) langMap[idx] = match[1]; });
                if(Object.keys(langMap).length === 0) return addToast("No matching Target Language columns found. Headers must look like: Target [de]", "error");
                let updatedCount = 0; let ignoredCount = 0; const nodeMap = new Map(); const ansMap = new Map(); 
                project.dialogs.forEach(d => { d.nodes.filter(n => n.type === 'Text').forEach(n => { nodeMap.set(n.data.key, n); n.data.answers.forEach((ans, idx) => { ansMap.set(ans.key, { node: n, index: idx }); }); }); });
                for(let i=1; i<rows.length; i++) {
                    const row = rows[i]; if(!row[keyIdx]) continue; const key = row[keyIdx]; let targetObj = null;
                    if(nodeMap.has(key)) targetObj = nodeMap.get(key).data; else if (ansMap.has(key)) { const info = ansMap.get(key); targetObj = info.node.data.answers[info.index]; } else { ignoredCount++; continue; }
                    let rowUpdated = false; for(const colIdx in langMap) { const lang = langMap[colIdx]; const newVal = row[colIdx]; if(newVal !== undefined) { targetObj.translations[lang] = newVal; rowUpdated = true; } }
                    if(rowUpdated) updatedCount++;
                } markAllDirty(); addToast(`Import Complete.\n\nKeys Updated: ${updatedCount}\nKeys Ignored (Unknown): ${ignoredCount}\nLanguages Processed: ${Object.values(langMap).join(', ')}`, "success");
            } catch (e) { addToast("Error importing CSV: " + e.message, "error"); }
        };

        const processImport = () => {
            try {
                const d = JSON.parse(importData.value);
                if(d.dialogs) { 
                    if (!d.folders) d.folders = []; if(d.characters) { d.characters.forEach(c => { if(!c.variables) c.variables = []; if(!c.description) c.description = ''; }); }
                    d.dialogs.forEach(dialog => {
                        if (dialog.folderId === undefined) dialog.folderId = null; if (!dialog.variables) dialog.variables = []; 
                        dialog.variables.forEach(v => { if (v.resetOnStart === undefined) v.resetOnStart = true; });
                        dialog.nodes.forEach(n => {
                            if(n.type === 'Text') {
                                if(n.data.note === undefined) n.data.note = '';
                                if(n.data.answers) { n.data.answers.forEach(a => { if(!a.translations) { a.translations = {}; project.settings.languages.forEach(l => a.translations[l] = a.text || ''); delete a.text; } if(!a.key) a.key = 'ANS_' + Math.floor(Math.random() * 10000); if(a.note === undefined) a.note = ''; }); }
                            }
                            if(n.type === 'Compare' && !n.data.compType) n.data.compType = 'string';
                            if(['And','NAnd','Or','NOr','XOr'].includes(n.type)) { if(!n.data.inputCount) n.data.inputCount = 2; }
                            if(n.type === 'FireEvent') { if(n.data.inputCount === undefined) n.data.inputCount = 0; if(n.data.eventName === undefined) n.data.eventName = ''; }
                        });
                    });
                    Object.assign(project, d); 
                    if (project.uiState) {
                        if(project.uiState.gridSize) editor.gridSize = project.uiState.gridSize; if(project.uiState.snap !== undefined) editor.snap = project.uiState.snap; if(project.uiState.sections) Object.assign(ui.sections, project.uiState.sections); if(project.uiState.overlayCollapsed !== undefined) ui.overlayCollapsed = project.uiState.overlayCollapsed;
                        if(project.uiState.expandedFolders) { expandedFolderIds.clear(); project.uiState.expandedFolders.forEach(id => expandedFolderIds.add(id)); }
                        if(project.uiState.collapsedCharacters) { collapsedCharacterIds.clear(); project.uiState.collapsedCharacters.forEach(id => collapsedCharacterIds.add(id)); }
                    } showExport.value = false; addToast("Project Loaded Successfully", "success"); markAllDirty(); updateGraph();
                } else addToast("Invalid Project Data Structure", "error");
                nextTick(() => updateTick.value++);
            } catch(e) { addToast("Error loading file: " + e.message, "error"); }
        };

        return {
            project, activeDialogId, activeDialog, ui, canvasRef, pan, zoom, activeNodes, activeConnections, showExport, importData, newLang, editor, loc, history,
            dragLinePath, selectedNodeId, selectedConnectionId, selectedNodeIds, hoverGroupId, removeGroupId,
            handleMove, handleUp, startPan, handleZoom, startNodeDrag, onNodeMouseDown, onCanvasMouseDown,
            addNode, deleteNode, createGroup, detachFromGroup, hasGroupedNodesSelected, deleteSelected,
            startConnect, finishConnect, canDrop, addDialog, deleteDialog, addVariable, deleteVariable, addCharacter, deleteCharacter, addCharacterVariable, deleteCharacterVariable, addLang, toggle,
            getNodeHeaderColor, getPath, selectConnection, copyToClipboard, downloadFile, exportLocalization, triggerImport, handleFileUpload, processImport, triggerLocImport, handleLocUpload,
            addFolder, onDrop: handleDrop, onCanvasDrop, onNodeDrop, renameTreeItem, deleteTreeItem, fitView, isDraggingNode, setDrag,
            modal, showConfirm, showPrompt, closeModal, confirmModal, modalInput, selectionRect, isSelecting, validationErrors, validateVars, validateChars, markActiveDirty, collapsedCharacterIds, toggleChar, 
            toastSystem, addToast, removeToast, getToastIcon, needsExpand, addDialogVariable, deleteDialogVariable, filteredMenuItems, flatContextItems, onCtxKeyDown, ctxSearch, NodeDefs, saveSnapshot, commitProp
        };
    }
});

// UI RENDERER COMPONENT - Handles the declarative UI for all nodes
app.component('ui-renderer', {
    props: ['ui', 'node', 'data', 'index', 'listDef'],
    setup(props) {
        const canDrop = inject('canDrop');
        const startConnect = inject('startConnect');
        const finishConnect = inject('finishConnect');
        const NodeContext = inject('NodeContext');
        const markActiveDirty = inject('markActiveDirty');
        const updateGraph = inject('updateGraph'); 

        const replaceIdx = (str) => typeof str === 'string' && props.index !== undefined ? str.replace(/\$index/g, props.index) : str;
        const getSockType = (item) => typeof item.sockType === 'function' ? item.sockType(props.node, NodeContext) : item.sockType;

        const addSocket = (item) => { props.data[item.model]++; markActiveDirty(); updateGraph(); };
        const remSocket = (item) => {
            if (props.data[item.model] > (item.min || 0)) {
                const sockName = item.idPrefix + (props.data[item.model] - 1);
                NodeContext.removeConnectionsToSocket(props.node.id, sockName);
                props.data[item.model]--; markActiveDirty(); updateGraph();
            }
        };

        const addItem = (item) => { if(item.onAdd) item.onAdd(NodeContext, props.node); markActiveDirty(); updateGraph(); };
        
        const handleAction = (itemDef) => {
            if (itemDef.action === 'remove' && props.listDef && props.listDef.onRemove) {
                props.listDef.onRemove(NodeContext, props.node, props.index);
                markActiveDirty();
                updateGraph();
            }
        };

        const onVarChange = () => {
             const type = NodeContext.getVarType(props.data.variableId);
             if (!['int', 'float', 'number'].includes(type)) props.data.operation = '=';
             markActiveDirty();
        };

        return { canDrop, startConnect, finishConnect, NodeContext, markActiveDirty, updateGraph, replaceIdx, getSockType, addSocket, remSocket, addItem, handleAction, onVarChange };
    },
    template: `
        <template v-for="(item, i) in ui" :key="i">
            
            <div v-if="item.type === 'row'" class="socket-row" :class="[item.justify || 'left', item.class]">
                <ui-renderer :ui="item.items" :node="node" :data="data" :index="index" :list-def="listDef" />
            </div>

            <div v-else-if="item.type === 'socket'" class="socket-hitbox" :id="'soc-' + node.id + '-' + replaceIdx(item.id)" :class="{'can-drop': canDrop(item.dir, getSockType(item))}" @mousedown.stop="startConnect(node.id, replaceIdx(item.id), getSockType(item), $event)" @mouseup.stop="finishConnect(node.id, replaceIdx(item.id), getSockType(item))">
                <div class="socket" :style="{ background: NodeContext.SocketTypes[getSockType(item)]?.color || '#888', borderRadius: NodeContext.SocketTypes[getSockType(item)]?.shape === 'circle' ? '50%' : '2px' }" :title="item.title || getSockType(item)"></div>
            </div>

            <span v-else-if="item.type === 'label'" class="text-sm" :class="item.class" :style="item.style">{{ replaceIdx(item.text) }}</span>
            <span v-else-if="item.type === 'dynamic_label'" class="text-sm" :class="item.class" :style="item.style">{{ typeof item.text === 'function' ? item.text(node, NodeContext) : replaceIdx(item.text) }}</span>

            <input v-else-if="item.type === 'input'" v-model="data[item.model]" @focus="NodeContext.saveSnapshot(data, item.model)" @change="e => { NodeContext.commitProp(data, item.model, e.target.value); markActiveDirty(); }" class="text-sm" :class="item.class" :style="item.style" :placeholder="item.placeholder">
            <input v-else-if="item.type === 'input_lang'" v-model="data[item.model][NodeContext.project.settings.currentLang]" @focus="NodeContext.saveSnapshot(data[item.model], NodeContext.project.settings.currentLang)" @change="e => { NodeContext.commitProp(data[item.model], NodeContext.project.settings.currentLang, e.target.value); markActiveDirty(); }" class="text-sm" :class="item.class" :style="item.style" :placeholder="item.placeholder">
            <textarea v-else-if="item.type === 'textarea_lang'" v-model="data[item.model][NodeContext.project.settings.currentLang]" @focus="NodeContext.saveSnapshot(data[item.model], NodeContext.project.settings.currentLang)" @change="e => { NodeContext.commitProp(data[item.model], NodeContext.project.settings.currentLang, e.target.value); markActiveDirty(); }" rows="2" class="text-sm" :class="item.class" :style="item.style" :placeholder="item.placeholder"></textarea>

            <button v-else-if="item.type === 'button'" class="icon-btn" :class="item.class" @click="handleAction(item)"><span class="icon">{{ item.icon }}</span></button>

            <select v-else-if="item.type === 'dialog_select'" v-model="data[item.model]" class="text-sm" @change="markActiveDirty">
                <option :value="null">-- None --</option>
                <option v-for="d in NodeContext.project.dialogs" :value="d.id">{{ d.name }}</option>
            </select>

            <select v-else-if="item.type === 'char_select'" v-model="data[item.model]" class="text-sm" @change="markActiveDirty">
                <option :value="null">Narrator</option>
                <option v-for="c in NodeContext.project.characters" :value="c.id">{{ c.name }}</option>
            </select>

            <select v-else-if="item.type === 'var_select'" v-model="data[item.model]" class="text-sm" :class="{error: !data[item.model]}" @change="onVarChange; markActiveDirty()">
                <option :value="null">Select Var...</option>
                <optgroup label="Dialog (Local)" v-if="NodeContext.activeDialog.value"><option v-for="v in NodeContext.activeDialog.value.variables" :value="v.id"># - {{ v.name }}</option></optgroup>
                <optgroup label="Global"><option v-for="v in NodeContext.project.variables" :value="v.id">{{ v.name }}</option></optgroup>
                <optgroup v-for="c in NodeContext.project.characters" :label="c.name"><option v-for="v in c.variables" :value="v.id">{{ c.name + "." + v.name }}</option></optgroup>
            </select>

            <div v-else-if="item.type === 'dynamic_list'" class="mt-2">
                <div class="flex center mt-2">
                     <span class="text-sm bold">{{ item.label }}</span>
                     <button class="tag ml-2 icon-btn" :title="item.addTitle" @click="addItem(item)"><span class="icon">add</span></button>
                </div>
                <div v-for="(listItem, lIdx) in data[item.model]" :key="lIdx" class="mt-2" style="border-top:1px solid #333; padding-top:4px">
                     <ui-renderer :ui="item.itemUi" :node="node" :data="listItem" :index="lIdx" :list-def="item" />
                </div>
                <div v-if="data[item.model].length === 0 && item.emptyUi" class="mt-2">
                     <ui-renderer :ui="item.emptyUi" :node="node" :data="data" />
                </div>
            </div>

            <div v-else-if="item.type === 'dynamic_sockets'" class="flex col">
                <div class="flex center gap-sm mb-2" v-if="item.showControls">
                     <span class="text-sm text-muted">{{ item.label }}: {{ data[item.model] }}</span>
                     <div class="grow"></div>
                     <button class="small icon-btn" @click="remSocket(item)" title="Remove"><span class="icon" style="font-size:14px">remove</span></button>
                     <button class="small icon-btn" @click="addSocket(item)" title="Add"><span class="icon" style="font-size:14px">add</span></button>
                </div>
                <div v-for="n in data[item.model]" :key="n" class="socket-row left mb-1">
                     <div class="socket-hitbox" :id="'soc-' + node.id + '-' + item.idPrefix + (n-1)" :class="{'can-drop': canDrop('in', item.sockType)}" @mousedown.stop="startConnect(node.id, item.idPrefix + (n-1), item.sockType, $event)" @mouseup.stop="finishConnect(node.id, item.idPrefix + (n-1), item.sockType)">
                         <div class="socket" :style="{ background: NodeContext.SocketTypes[item.sockType]?.color || '#888', borderRadius: NodeContext.SocketTypes[item.sockType]?.shape === 'circle' ? '50%' : '2px' }"></div>
                     </div>
                     <span class="text-sm ml-2">{{ item.labelPrefix }} {{ n }}</span>
                </div>
            </div>

            <div v-else-if="item.type === 'set_var_logic'" class="flex gap-sm center mt-2">
                <select v-if="['int','float','number'].includes(NodeContext.getVarType(data.variableId))" v-model="data.operation" class="text-sm" style="width:50px" @change="markActiveDirty"><option value="=">=</option><option value="+=">+=</option><option value="-=">-=</option></select>
                <span v-else class="text-sm bold" style="width:20px; text-align:center;">=</span>
                
                <div class="socket-hitbox" :id="'soc-' + node.id + '-in_val'" :class="{'can-drop': canDrop('in', NodeContext.getVarType(data.variableId) || 'any')}" @mousedown.stop="startConnect(node.id, 'in_val', NodeContext.getVarType(data.variableId) || 'any', $event)" @mouseup.stop="finishConnect(node.id, 'in_val', NodeContext.getVarType(data.variableId) || 'any')">
                     <div class="socket" :style="{ background: NodeContext.SocketTypes[NodeContext.getVarType(data.variableId) || 'any']?.color || '#888', borderRadius: '2px' }" title="Input Value"></div>
                </div>

                <template v-if="NodeContext.getVarType(data.variableId) === 'bool'">
                    <div class="grow flex center">
                        <input type="checkbox" :id="'sv-'+node.id" class="toggle-checkbox" v-model="data.value" true-value="true" false-value="false" @change="markActiveDirty">
                        <label :for="'sv-'+node.id" class="toggle-label"></label>
                        <span class="text-sm ml-2">{{ data.value === 'true' ? 'True' : 'False' }}</span>
                    </div>
                </template>
                <template v-else>
                    <input v-model="data.value" @focus="NodeContext.saveSnapshot(data, 'value')" @change="e => { NodeContext.commitProp(data, 'value', e.target.value); markActiveDirty(); }" class="text-sm grow" placeholder="Val">
                </template>
            </div>

            <div v-else-if="item.type === 'compare_logic'" class="flex gap-sm mt-2">
                <template v-if="NodeContext.getConnectedType(node, 'in_val') === 'bool'">
                    <select v-model="data.operator" class="text-sm" style="width:60px" @change="markActiveDirty"><option value="==">==</option><option value="!=">!=</option></select>
                    <div class="grow flex center">
                        <input type="checkbox" :id="'cmp-'+node.id" class="toggle-checkbox" v-model="data.compareValue" true-value="true" false-value="false" @change="markActiveDirty">
                        <label :for="'cmp-'+node.id" class="toggle-label"></label>
                        <span class="text-sm ml-2">{{ data.compareValue === 'true' ? 'True' : 'False' }}</span>
                    </div>
                </template>
                <template v-else-if="['int','float','number'].includes(NodeContext.getConnectedType(node, 'in_val'))">
                    <select v-model="data.operator" class="text-sm" style="width:60px" @change="markActiveDirty"><option value="==">==</option><option value="!=">!=</option><option value=">">&gt;</option><option value="<">&lt;</option><option value=">=">&ge;</option><option value="<=">&le;</option></select>
                    <input type="number" v-model="data.compareValue" @focus="NodeContext.saveSnapshot(data, 'compareValue')" @change="e => { NodeContext.commitProp(data, 'compareValue', e.target.value); markActiveDirty(); }" class="text-sm grow" placeholder="0">
                </template>
                <template v-else>
                    <select v-model="data.operator" class="text-sm" style="width:80px" @change="markActiveDirty"><option value="==">==</option><option value="!=">!=</option><option value="contains">Contains</option></select>
                    <input v-model="data.compareValue" @focus="NodeContext.saveSnapshot(data, 'compareValue')" @change="e => { NodeContext.commitProp(data, 'compareValue', e.target.value); markActiveDirty(); }" class="text-sm grow" placeholder="Text">
                </template>
            </div>

        </template>
    `
});

app.mount('#app');
</script>
</body>
</html>